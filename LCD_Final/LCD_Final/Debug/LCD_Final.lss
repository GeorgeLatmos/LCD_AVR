
LCD_Final.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000042  00800100  00000f02  00000f76  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f02  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      0000005c  00000000  00000000  00000fb8  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001014  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000140  00000000  00000000  00001054  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001dda  00000000  00000000  00001194  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000cf3  00000000  00000000  00002f6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000e2b  00000000  00000000  00003c61  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002b4  00000000  00000000  00004a8c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005d9  00000000  00000000  00004d40  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000136a  00000000  00000000  00005319  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000108  00000000  00000000  00006683  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
   8:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
   c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  10:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  14:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  18:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  1c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  20:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  24:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  28:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  2c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  30:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  34:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  38:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  3c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  40:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  44:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  48:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  4c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  50:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  54:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  58:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  5c:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  60:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>
  64:	0c 94 49 00 	jmp	0x92	; 0x92 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 e0       	ldi	r30, 0x02	; 2
  7c:	ff e0       	ldi	r31, 0x0F	; 15
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 34       	cpi	r26, 0x42	; 66
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>
  8a:	0e 94 89 02 	call	0x512	; 0x512 <main>
  8e:	0c 94 7f 07 	jmp	0xefe	; 0xefe <_exit>

00000092 <__bad_interrupt>:
  92:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000096 <dhtxxread>:
	SREG = sreg;
	return DHTXX_ERROR_OK;
}

uint8_t dhtxxread( unsigned char dev, volatile uint8_t *port, volatile uint8_t *direction, volatile uint8_t *portin, uint8_t mask, int *temperature, int *humidity )
{
  96:	6f 92       	push	r6
  98:	7f 92       	push	r7
  9a:	8f 92       	push	r8
  9c:	9f 92       	push	r9
  9e:	af 92       	push	r10
  a0:	bf 92       	push	r11
  a2:	cf 92       	push	r12
  a4:	df 92       	push	r13
  a6:	ef 92       	push	r14
  a8:	ff 92       	push	r15
  aa:	0f 93       	push	r16
  ac:	1f 93       	push	r17
  ae:	cf 93       	push	r28
  b0:	df 93       	push	r29
  b2:	00 d0       	rcall	.+0      	; 0xb4 <dhtxxread+0x1e>
  b4:	00 d0       	rcall	.+0      	; 0xb6 <dhtxxread+0x20>
  b6:	1f 92       	push	r1
  b8:	cd b7       	in	r28, 0x3d	; 61
  ba:	de b7       	in	r29, 0x3e	; 62
  bc:	68 2e       	mov	r6, r24
  be:	f9 01       	movw	r30, r18
	uint8_t sreg = SREG; //Status register backup
  c0:	9f b7       	in	r25, 0x3f	; 63
	uint8_t cs = 0; //Checksum
	uint8_t ec = 0;
	uint8_t i;

	//Check if device type is correct
	if ( dev != DHTXX_DHT11 && dev != DHTXX_DHT22 ) return DHTXX_ERROR_OTHER;
  c2:	21 e0       	ldi	r18, 0x01	; 1
  c4:	28 17       	cp	r18, r24
  c6:	08 f4       	brcc	.+2      	; 0xca <dhtxxread+0x34>
  c8:	c4 c0       	rjmp	.+392    	; 0x252 <dhtxxread+0x1bc>

	//Send start signal
	*direction &= ~mask;
  ca:	da 01       	movw	r26, r20
  cc:	8c 91       	ld	r24, X
  ce:	10 2f       	mov	r17, r16
  d0:	10 95       	com	r17
  d2:	81 23       	and	r24, r17
  d4:	8c 93       	st	X, r24
	*port &= ~mask;
  d6:	db 01       	movw	r26, r22
  d8:	8c 91       	ld	r24, X
  da:	81 23       	and	r24, r17
  dc:	8c 93       	st	X, r24
	*direction |= mask;
  de:	da 01       	movw	r26, r20
  e0:	8c 91       	ld	r24, X
  e2:	80 2b       	or	r24, r16
  e4:	8c 93       	st	X, r24

	//Adjust start signal time for DHT11 and DHT22
	if ( dev == DHTXX_DHT22 )
  e6:	62 12       	cpse	r6, r18
  e8:	07 c0       	rjmp	.+14     	; 0xf8 <dhtxxread+0x62>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  ea:	af ec       	ldi	r26, 0xCF	; 207
  ec:	b7 e0       	ldi	r27, 0x07	; 7
  ee:	11 97       	sbiw	r26, 0x01	; 1
  f0:	f1 f7       	brne	.-4      	; 0xee <dhtxxread+0x58>
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <dhtxxread+0x5e>
  f4:	00 00       	nop
  f6:	09 c0       	rjmp	.+18     	; 0x10a <dhtxxread+0x74>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  f8:	bf ef       	ldi	r27, 0xFF	; 255
  fa:	20 ee       	ldi	r18, 0xE0	; 224
  fc:	30 e0       	ldi	r19, 0x00	; 0
  fe:	b1 50       	subi	r27, 0x01	; 1
 100:	20 40       	sbci	r18, 0x00	; 0
 102:	30 40       	sbci	r19, 0x00	; 0
 104:	e1 f7       	brne	.-8      	; 0xfe <dhtxxread+0x68>
 106:	00 c0       	rjmp	.+0      	; 0x108 <dhtxxread+0x72>
 108:	00 00       	nop
		_delay_us( 500 );
	else
		_delay_ms( 18 );

	//Turn pin into input, disable interrupts and wait for acknowledgement
	cli( );
 10a:	f8 94       	cli
	*direction &= ~mask;
 10c:	da 01       	movw	r26, r20
 10e:	8c 91       	ld	r24, X
 110:	81 23       	and	r24, r17
 112:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 114:	a7 e1       	ldi	r26, 0x17	; 23
 116:	b1 e0       	ldi	r27, 0x01	; 1
 118:	11 97       	sbiw	r26, 0x01	; 1
 11a:	f1 f7       	brne	.-4      	; 0x118 <dhtxxread+0x82>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <dhtxxread+0x88>
 11e:	00 00       	nop
	_delay_us( 30 + 40 );

	//Communication check 1
	if ( *portin & mask )
 120:	80 81       	ld	r24, Z
 122:	80 23       	and	r24, r16
 124:	19 f0       	breq	.+6      	; 0x12c <dhtxxread+0x96>
	{
		SREG = sreg;
 126:	9f bf       	out	0x3f, r25	; 63
		return DHTXX_ERROR_COMM;
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	98 c0       	rjmp	.+304    	; 0x25c <dhtxxread+0x1c6>
 12c:	af e3       	ldi	r26, 0x3F	; 63
 12e:	b1 e0       	ldi	r27, 0x01	; 1
 130:	11 97       	sbiw	r26, 0x01	; 1
 132:	f1 f7       	brne	.-4      	; 0x130 <dhtxxread+0x9a>
 134:	00 c0       	rjmp	.+0      	; 0x136 <dhtxxread+0xa0>
 136:	00 00       	nop
	}

	_delay_us( 80 );

	//Communication check 2
	if ( !( *portin & mask ) )
 138:	20 81       	ld	r18, Z
 13a:	20 23       	and	r18, r16
 13c:	19 f4       	brne	.+6      	; 0x144 <dhtxxread+0xae>
	{
		SREG = sreg;
 13e:	9f bf       	out	0x3f, r25	; 63
		return DHTXX_ERROR_COMM;
 140:	81 e0       	ldi	r24, 0x01	; 1
 142:	8c c0       	rjmp	.+280    	; 0x25c <dhtxxread+0x1c6>
	}

	//Restore interrupts status
	SREG = sreg;
 144:	9f bf       	out	0x3f, r25	; 63
 146:	b5 ed       	ldi	r27, 0xD5	; 213
 148:	ba 95       	dec	r27
 14a:	f1 f7       	brne	.-4      	; 0x148 <dhtxxread+0xb2>
 14c:	00 00       	nop
 14e:	9e 01       	movw	r18, r28
 150:	2f 5f       	subi	r18, 0xFF	; 255
 152:	3f 4f       	sbci	r19, 0xFF	; 255
 154:	5e 01       	movw	r10, r28
 156:	96 e0       	ldi	r25, 0x06	; 6
 158:	a9 0e       	add	r10, r25
 15a:	b1 1c       	adc	r11, r1
- 28us / 70us data impulse
*/

static uint8_t dhtxxreadb( volatile uint8_t *port, volatile uint8_t *direction, volatile uint8_t *portin, uint8_t mask, uint8_t *dest )
{
	uint8_t sreg = SREG; //Backup status register
 15c:	7f b6       	in	r7, 0x3f	; 63
	uint8_t data = 0;
	uint8_t timeoutcnt = 0;
	uint8_t i = 0;

	//Disable interrupts
	cli( );
 15e:	f8 94       	cli

	//Turn pin into input
	*direction &= ~mask;
 160:	da 01       	movw	r26, r20
 162:	9c 91       	ld	r25, X
 164:	91 23       	and	r25, r17
 166:	9c 93       	st	X, r25
	*port &= ~mask;
 168:	db 01       	movw	r26, r22
 16a:	9c 91       	ld	r25, X
 16c:	91 23       	and	r25, r17
 16e:	9c 93       	st	X, r25

	//Get 8 bits
	for ( i = 128; i; i >>= 1 )
 170:	68 94       	set
 172:	99 24       	eor	r9, r9
 174:	97 f8       	bld	r9, 7
*/

static uint8_t dhtxxreadb( volatile uint8_t *port, volatile uint8_t *direction, volatile uint8_t *portin, uint8_t mask, uint8_t *dest )
{
	uint8_t sreg = SREG; //Backup status register
	uint8_t data = 0;
 176:	81 2c       	mov	r8, r1
 178:	25 c0       	rjmp	.+74     	; 0x1c4 <dhtxxread+0x12e>
 17a:	b1 50       	subi	r27, 0x01	; 1
	{
		//Wait for the sync part to finish
		timeoutcnt = 0;
		while ( !( *portin & mask ) )
		{
			if ( timeoutcnt++ > DHTXX_TIMEOUT )
 17c:	19 f4       	brne	.+6      	; 0x184 <dhtxxread+0xee>
			{
				SREG = sreg;
 17e:	7f be       	out	0x3f, r7	; 63
 180:	6c c0       	rjmp	.+216    	; 0x25a <dhtxxread+0x1c4>
	//Get 8 bits
	for ( i = 128; i; i >>= 1 )
	{
		//Wait for the sync part to finish
		timeoutcnt = 0;
		while ( !( *portin & mask ) )
 182:	bd e3       	ldi	r27, 0x3D	; 61
 184:	95 e0       	ldi	r25, 0x05	; 5
 186:	9a 95       	dec	r25
 188:	f1 f7       	brne	.-4      	; 0x186 <dhtxxread+0xf0>
 18a:	00 00       	nop
 18c:	90 81       	ld	r25, Z
 18e:	90 23       	and	r25, r16
 190:	a1 f3       	breq	.-24     	; 0x17a <dhtxxread+0xe4>
 192:	a0 ea       	ldi	r26, 0xA0	; 160
 194:	aa 95       	dec	r26
 196:	f1 f7       	brne	.-4      	; 0x194 <dhtxxread+0xfe>
			_delay_us( 1 );
		}

		_delay_us( 30 );

		if ( *portin & mask ) data |= i;
 198:	90 81       	ld	r25, Z
 19a:	90 23       	and	r25, r16
 19c:	09 f0       	breq	.+2      	; 0x1a0 <dhtxxread+0x10a>
 19e:	89 28       	or	r8, r9

		//Wait for the data part to finish
		timeoutcnt = 0;
		while ( *portin & mask )
 1a0:	90 81       	ld	r25, Z
 1a2:	90 23       	and	r25, r16
 1a4:	29 f4       	brne	.+10     	; 0x1b0 <dhtxxread+0x11a>
 1a6:	0c c0       	rjmp	.+24     	; 0x1c0 <dhtxxread+0x12a>
 1a8:	b1 50       	subi	r27, 0x01	; 1
		{
			if ( timeoutcnt++ > DHTXX_TIMEOUT )
 1aa:	19 f4       	brne	.+6      	; 0x1b2 <dhtxxread+0x11c>
			{
				SREG = sreg;
 1ac:	7f be       	out	0x3f, r7	; 63
 1ae:	55 c0       	rjmp	.+170    	; 0x25a <dhtxxread+0x1c4>

		if ( *portin & mask ) data |= i;

		//Wait for the data part to finish
		timeoutcnt = 0;
		while ( *portin & mask )
 1b0:	bd e3       	ldi	r27, 0x3D	; 61
 1b2:	95 e0       	ldi	r25, 0x05	; 5
 1b4:	9a 95       	dec	r25
 1b6:	f1 f7       	brne	.-4      	; 0x1b4 <dhtxxread+0x11e>
 1b8:	00 00       	nop
 1ba:	90 81       	ld	r25, Z
 1bc:	90 23       	and	r25, r16
 1be:	a1 f7       	brne	.-24     	; 0x1a8 <dhtxxread+0x112>
	//Turn pin into input
	*direction &= ~mask;
	*port &= ~mask;

	//Get 8 bits
	for ( i = 128; i; i >>= 1 )
 1c0:	96 94       	lsr	r9
 1c2:	21 f0       	breq	.+8      	; 0x1cc <dhtxxread+0x136>
	{
		//Wait for the sync part to finish
		timeoutcnt = 0;
		while ( !( *portin & mask ) )
 1c4:	90 81       	ld	r25, Z
 1c6:	90 23       	and	r25, r16
 1c8:	e1 f2       	breq	.-72     	; 0x182 <dhtxxread+0xec>
 1ca:	e3 cf       	rjmp	.-58     	; 0x192 <dhtxxread+0xfc>
			}
			_delay_us( 1 );
		}
	}

	*dest = data;
 1cc:	d9 01       	movw	r26, r18
 1ce:	8d 92       	st	X+, r8
 1d0:	9d 01       	movw	r18, r26

	SREG = sreg;
 1d2:	7f be       	out	0x3f, r7	; 63
	//Restore interrupts status
	SREG = sreg;
	_delay_us( 40 );

	//Read data from sensor
	for ( i = 0; i < 5; i++ )
 1d4:	aa 15       	cp	r26, r10
 1d6:	bb 05       	cpc	r27, r11
 1d8:	09 f0       	breq	.+2      	; 0x1dc <dhtxxread+0x146>
 1da:	c0 cf       	rjmp	.-128    	; 0x15c <dhtxxread+0xc6>
		if ( ec ) return ec;
	}

	//Checksum calculation
	for ( i = 0; i < 4; i++ )
		cs += data[i];
 1dc:	49 81       	ldd	r20, Y+1	; 0x01
 1de:	6a 81       	ldd	r22, Y+2	; 0x02
 1e0:	94 2f       	mov	r25, r20
 1e2:	96 0f       	add	r25, r22
 1e4:	2b 81       	ldd	r18, Y+3	; 0x03
 1e6:	92 0f       	add	r25, r18
 1e8:	3c 81       	ldd	r19, Y+4	; 0x04
	if ( cs != data[4] )
 1ea:	93 0f       	add	r25, r19
 1ec:	5d 81       	ldd	r21, Y+5	; 0x05
 1ee:	95 13       	cpse	r25, r21
 1f0:	32 c0       	rjmp	.+100    	; 0x256 <dhtxxread+0x1c0>
		return DHTXX_ERROR_CHECKSUM;

	//Output values
	if ( dev == DHTXX_DHT22 ) //DHT22
 1f2:	b1 e0       	ldi	r27, 0x01	; 1
 1f4:	6b 12       	cpse	r6, r27
 1f6:	0e c0       	rjmp	.+28     	; 0x214 <dhtxxread+0x17e>
	{
		//Will return humidity*10 and temperature*10
		*humidity = data[0] << 8 | data[1];
 1f8:	70 e0       	ldi	r23, 0x00	; 0
 1fa:	fb 01       	movw	r30, r22
 1fc:	f4 2b       	or	r31, r20
 1fe:	d6 01       	movw	r26, r12
 200:	ed 93       	st	X+, r30
 202:	fc 93       	st	X, r31
		*temperature = data[2] << 8 | data[3];
 204:	43 2f       	mov	r20, r19
 206:	50 e0       	ldi	r21, 0x00	; 0
 208:	fa 01       	movw	r30, r20
 20a:	f2 2b       	or	r31, r18
 20c:	d7 01       	movw	r26, r14
 20e:	ed 93       	st	X+, r30
 210:	fc 93       	st	X, r31
 212:	24 c0       	rjmp	.+72     	; 0x25c <dhtxxread+0x1c6>
	}
	else //DHT11
	{
		*humidity = data[0] * 10;
 214:	50 e0       	ldi	r21, 0x00	; 0
 216:	ba 01       	movw	r22, r20
 218:	66 0f       	add	r22, r22
 21a:	77 1f       	adc	r23, r23
 21c:	44 0f       	add	r20, r20
 21e:	55 1f       	adc	r21, r21
 220:	44 0f       	add	r20, r20
 222:	55 1f       	adc	r21, r21
 224:	44 0f       	add	r20, r20
 226:	55 1f       	adc	r21, r21
 228:	46 0f       	add	r20, r22
 22a:	57 1f       	adc	r21, r23
 22c:	f6 01       	movw	r30, r12
 22e:	51 83       	std	Z+1, r21	; 0x01
 230:	40 83       	st	Z, r20
		*temperature = data[2] * 10;
 232:	30 e0       	ldi	r19, 0x00	; 0
 234:	a9 01       	movw	r20, r18
 236:	44 0f       	add	r20, r20
 238:	55 1f       	adc	r21, r21
 23a:	22 0f       	add	r18, r18
 23c:	33 1f       	adc	r19, r19
 23e:	22 0f       	add	r18, r18
 240:	33 1f       	adc	r19, r19
 242:	22 0f       	add	r18, r18
 244:	33 1f       	adc	r19, r19
 246:	24 0f       	add	r18, r20
 248:	35 1f       	adc	r19, r21
 24a:	d7 01       	movw	r26, r14
 24c:	2d 93       	st	X+, r18
 24e:	3c 93       	st	X, r19
 250:	05 c0       	rjmp	.+10     	; 0x25c <dhtxxread+0x1c6>
	uint8_t cs = 0; //Checksum
	uint8_t ec = 0;
	uint8_t i;

	//Check if device type is correct
	if ( dev != DHTXX_DHT11 && dev != DHTXX_DHT22 ) return DHTXX_ERROR_OTHER;
 252:	83 e0       	ldi	r24, 0x03	; 3
 254:	03 c0       	rjmp	.+6      	; 0x25c <dhtxxread+0x1c6>

	//Checksum calculation
	for ( i = 0; i < 4; i++ )
		cs += data[i];
	if ( cs != data[4] )
		return DHTXX_ERROR_CHECKSUM;
 256:	82 e0       	ldi	r24, 0x02	; 2
 258:	01 c0       	rjmp	.+2      	; 0x25c <dhtxxread+0x1c6>

	//Communication check 2
	if ( !( *portin & mask ) )
	{
		SREG = sreg;
		return DHTXX_ERROR_COMM;
 25a:	81 e0       	ldi	r24, 0x01	; 1
		*humidity = data[0] * 10;
		*temperature = data[2] * 10;
	}

	return DHTXX_ERROR_OK;
}
 25c:	0f 90       	pop	r0
 25e:	0f 90       	pop	r0
 260:	0f 90       	pop	r0
 262:	0f 90       	pop	r0
 264:	0f 90       	pop	r0
 266:	df 91       	pop	r29
 268:	cf 91       	pop	r28
 26a:	1f 91       	pop	r17
 26c:	0f 91       	pop	r16
 26e:	ff 90       	pop	r15
 270:	ef 90       	pop	r14
 272:	df 90       	pop	r13
 274:	cf 90       	pop	r12
 276:	bf 90       	pop	r11
 278:	af 90       	pop	r10
 27a:	9f 90       	pop	r9
 27c:	8f 90       	pop	r8
 27e:	7f 90       	pop	r7
 280:	6f 90       	pop	r6
 282:	08 95       	ret

00000284 <dhtxxconvert>:

uint8_t dhtxxconvert( unsigned char dev, volatile uint8_t *port, volatile uint8_t *direction, volatile uint8_t *portin, uint8_t mask )
{
 284:	0f 93       	push	r16
	//Requests DHTxx device, but does not read the data (simply triggers conversion)

	uint8_t sreg = SREG; //Status register backup
 286:	9f b7       	in	r25, 0x3f	; 63

	//Check if device type is correct
	if ( dev != DHTXX_DHT11 && dev != DHTXX_DHT22 ) return DHTXX_ERROR_OTHER;
 288:	82 30       	cpi	r24, 0x02	; 2
 28a:	a0 f5       	brcc	.+104    	; 0x2f4 <dhtxxconvert+0x70>

	//Send start signal
	*direction &= ~mask;
 28c:	da 01       	movw	r26, r20
 28e:	fc 91       	ld	r31, X
 290:	e0 2f       	mov	r30, r16
 292:	e0 95       	com	r30
 294:	fe 23       	and	r31, r30
 296:	fc 93       	st	X, r31
	*port &= ~mask;
 298:	db 01       	movw	r26, r22
 29a:	fc 91       	ld	r31, X
 29c:	fe 23       	and	r31, r30
 29e:	fc 93       	st	X, r31
	*direction |= mask;
 2a0:	da 01       	movw	r26, r20
 2a2:	6c 91       	ld	r22, X
 2a4:	60 2b       	or	r22, r16
 2a6:	6c 93       	st	X, r22

	//Adjust start signal time for DHT11 and DHT22
	if ( dev == DHTXX_DHT22 )
 2a8:	81 30       	cpi	r24, 0x01	; 1
 2aa:	39 f4       	brne	.+14     	; 0x2ba <dhtxxconvert+0x36>
 2ac:	af ec       	ldi	r26, 0xCF	; 207
 2ae:	b7 e0       	ldi	r27, 0x07	; 7
 2b0:	11 97       	sbiw	r26, 0x01	; 1
 2b2:	f1 f7       	brne	.-4      	; 0x2b0 <dhtxxconvert+0x2c>
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <dhtxxconvert+0x32>
 2b6:	00 00       	nop
 2b8:	09 c0       	rjmp	.+18     	; 0x2cc <dhtxxconvert+0x48>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2ba:	bf ef       	ldi	r27, 0xFF	; 255
 2bc:	f0 ee       	ldi	r31, 0xE0	; 224
 2be:	60 e0       	ldi	r22, 0x00	; 0
 2c0:	b1 50       	subi	r27, 0x01	; 1
 2c2:	f0 40       	sbci	r31, 0x00	; 0
 2c4:	60 40       	sbci	r22, 0x00	; 0
 2c6:	e1 f7       	brne	.-8      	; 0x2c0 <dhtxxconvert+0x3c>
 2c8:	00 c0       	rjmp	.+0      	; 0x2ca <dhtxxconvert+0x46>
 2ca:	00 00       	nop
		_delay_us( 500 );
	else
		_delay_ms( 18 );

	//Turn pin into input, disable interrupts and wait for acknowledgement
	cli( );
 2cc:	f8 94       	cli
	*direction &= ~mask;
 2ce:	da 01       	movw	r26, r20
 2d0:	8c 91       	ld	r24, X
 2d2:	e8 23       	and	r30, r24
 2d4:	ec 93       	st	X, r30
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2d6:	e7 e1       	ldi	r30, 0x17	; 23
 2d8:	f1 e0       	ldi	r31, 0x01	; 1
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	f1 f7       	brne	.-4      	; 0x2da <dhtxxconvert+0x56>
 2de:	00 c0       	rjmp	.+0      	; 0x2e0 <dhtxxconvert+0x5c>
 2e0:	00 00       	nop
	_delay_us( 30 + 40 );

	//Communication check 1
	if ( *portin & mask )
 2e2:	d9 01       	movw	r26, r18
 2e4:	8c 91       	ld	r24, X
 2e6:	80 23       	and	r24, r16
 2e8:	19 f0       	breq	.+6      	; 0x2f0 <dhtxxconvert+0x6c>
	{
		SREG = sreg;
 2ea:	9f bf       	out	0x3f, r25	; 63
		return DHTXX_ERROR_COMM;
 2ec:	81 e0       	ldi	r24, 0x01	; 1
 2ee:	03 c0       	rjmp	.+6      	; 0x2f6 <dhtxxconvert+0x72>
	}

	SREG = sreg;
 2f0:	9f bf       	out	0x3f, r25	; 63
	return DHTXX_ERROR_OK;
 2f2:	01 c0       	rjmp	.+2      	; 0x2f6 <dhtxxconvert+0x72>
	//Requests DHTxx device, but does not read the data (simply triggers conversion)

	uint8_t sreg = SREG; //Status register backup

	//Check if device type is correct
	if ( dev != DHTXX_DHT11 && dev != DHTXX_DHT22 ) return DHTXX_ERROR_OTHER;
 2f4:	83 e0       	ldi	r24, 0x03	; 3
		return DHTXX_ERROR_COMM;
	}

	SREG = sreg;
	return DHTXX_ERROR_OK;
}
 2f6:	0f 91       	pop	r16
 2f8:	08 95       	ret

000002fa <I2C_Init>:

 * description :This function is used to initialize the I2C module
------------------------------------------------------------------------------------*/
void I2C_Init()
{
    TWSR=0x00; //set presca1er bits to zero
 2fa:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    TWBR=0x46; //SCL frequency is 50K for 16Mhz
 2fe:	86 e4       	ldi	r24, 0x46	; 70
 300:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    TWCR=0x04; //enab1e TWI module
 304:	84 e0       	ldi	r24, 0x04	; 4
 306:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 30a:	08 95       	ret

0000030c <I2C_Start>:
                      ____|         |____________

 ***************************************************************************************************/
void I2C_Start()
{
    TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
 30c:	84 ea       	ldi	r24, 0xA4	; 164
 30e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    while (!(TWCR & (1<<TWINT)));
 312:	ec eb       	ldi	r30, 0xBC	; 188
 314:	f0 e0       	ldi	r31, 0x00	; 0
 316:	80 81       	ld	r24, Z
 318:	88 23       	and	r24, r24
 31a:	ec f7       	brge	.-6      	; 0x316 <I2C_Start+0xa>
}
 31c:	08 95       	ret

0000031e <I2C_Stop>:

 ***************************************************************************************************/

void I2C_Stop(void)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
 31e:	84 e9       	ldi	r24, 0x94	; 148
 320:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 324:	8f e8       	ldi	r24, 0x8F	; 143
 326:	91 e0       	ldi	r25, 0x01	; 1
 328:	01 97       	sbiw	r24, 0x01	; 1
 32a:	f1 f7       	brne	.-4      	; 0x328 <I2C_Stop+0xa>
 32c:	00 c0       	rjmp	.+0      	; 0x32e <I2C_Stop+0x10>
 32e:	00 00       	nop
 330:	08 95       	ret

00000332 <I2C_Write>:


 ***************************************************************************************************/
void I2C_Write(uint8_t v_i2cData_u8)
{
    TWDR = v_i2cData_u8 ;
 332:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    TWCR = ((1<< TWINT) | (1<<TWEN));
 336:	84 e8       	ldi	r24, 0x84	; 132
 338:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    while (!(TWCR & (1 <<TWINT)));
 33c:	ec eb       	ldi	r30, 0xBC	; 188
 33e:	f0 e0       	ldi	r31, 0x00	; 0
 340:	80 81       	ld	r24, Z
 342:	88 23       	and	r24, r24
 344:	ec f7       	brge	.-6      	; 0x340 <I2C_Write+0xe>
		
		//WHERE IS ACK??
}
 346:	08 95       	ret

00000348 <I2C_Read>:


***************************************************************************************************/
uint8_t I2C_Read(uint8_t v_ackOption_u8)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (v_ackOption_u8<<TWEA));
 348:	20 e4       	ldi	r18, 0x40	; 64
 34a:	82 9f       	mul	r24, r18
 34c:	c0 01       	movw	r24, r0
 34e:	11 24       	eor	r1, r1
 350:	84 68       	ori	r24, 0x84	; 132
 352:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    while ( !(TWCR & (1 <<TWINT)));
 356:	ec eb       	ldi	r30, 0xBC	; 188
 358:	f0 e0       	ldi	r31, 0x00	; 0
 35a:	80 81       	ld	r24, Z
 35c:	88 23       	and	r24, r24
 35e:	ec f7       	brge	.-6      	; 0x35a <I2C_Read+0x12>
    return TWDR;
 360:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
}
 364:	08 95       	ret

00000366 <toggle_e>:

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
    }

}/* lcd_puts_p */
 366:	41 9a       	sbi	0x08, 1	; 8
 368:	85 e0       	ldi	r24, 0x05	; 5
 36a:	8a 95       	dec	r24
 36c:	f1 f7       	brne	.-4      	; 0x36a <toggle_e+0x4>
 36e:	00 00       	nop
 370:	41 98       	cbi	0x08, 1	; 8
 372:	08 95       	ret

00000374 <lcd_write>:
 374:	cf 93       	push	r28
 376:	df 93       	push	r29
 378:	d8 2f       	mov	r29, r24
 37a:	66 23       	and	r22, r22
 37c:	11 f0       	breq	.+4      	; 0x382 <lcd_write+0xe>
 37e:	43 9a       	sbi	0x08, 3	; 8
 380:	01 c0       	rjmp	.+2      	; 0x384 <lcd_write+0x10>
 382:	43 98       	cbi	0x08, 3	; 8
 384:	42 98       	cbi	0x08, 2	; 8
 386:	8a b1       	in	r24, 0x0a	; 10
 388:	8f 60       	ori	r24, 0x0F	; 15
 38a:	8a b9       	out	0x0a, r24	; 10
 38c:	cb b1       	in	r28, 0x0b	; 11
 38e:	c0 7f       	andi	r28, 0xF0	; 240
 390:	8d 2f       	mov	r24, r29
 392:	82 95       	swap	r24
 394:	8f 70       	andi	r24, 0x0F	; 15
 396:	8c 2b       	or	r24, r28
 398:	8b b9       	out	0x0b, r24	; 11
 39a:	0e 94 b3 01 	call	0x366	; 0x366 <toggle_e>
 39e:	df 70       	andi	r29, 0x0F	; 15
 3a0:	dc 2b       	or	r29, r28
 3a2:	db b9       	out	0x0b, r29	; 11
 3a4:	0e 94 b3 01 	call	0x366	; 0x366 <toggle_e>
 3a8:	cf 60       	ori	r28, 0x0F	; 15
 3aa:	cb b9       	out	0x0b, r28	; 11
 3ac:	df 91       	pop	r29
 3ae:	cf 91       	pop	r28
 3b0:	08 95       	ret

000003b2 <lcd_read>:
 3b2:	88 23       	and	r24, r24
 3b4:	11 f0       	breq	.+4      	; 0x3ba <lcd_read+0x8>
 3b6:	43 9a       	sbi	0x08, 3	; 8
 3b8:	01 c0       	rjmp	.+2      	; 0x3bc <lcd_read+0xa>
 3ba:	43 98       	cbi	0x08, 3	; 8
 3bc:	42 9a       	sbi	0x08, 2	; 8
 3be:	8a b1       	in	r24, 0x0a	; 10
 3c0:	80 7f       	andi	r24, 0xF0	; 240
 3c2:	8a b9       	out	0x0a, r24	; 10
 3c4:	41 9a       	sbi	0x08, 1	; 8
 3c6:	85 e0       	ldi	r24, 0x05	; 5
 3c8:	8a 95       	dec	r24
 3ca:	f1 f7       	brne	.-4      	; 0x3c8 <lcd_read+0x16>
 3cc:	00 00       	nop
 3ce:	99 b1       	in	r25, 0x09	; 9
 3d0:	41 98       	cbi	0x08, 1	; 8
 3d2:	85 e0       	ldi	r24, 0x05	; 5
 3d4:	8a 95       	dec	r24
 3d6:	f1 f7       	brne	.-4      	; 0x3d4 <lcd_read+0x22>
 3d8:	00 00       	nop
 3da:	41 9a       	sbi	0x08, 1	; 8
 3dc:	85 e0       	ldi	r24, 0x05	; 5
 3de:	8a 95       	dec	r24
 3e0:	f1 f7       	brne	.-4      	; 0x3de <lcd_read+0x2c>
 3e2:	00 00       	nop
 3e4:	29 b1       	in	r18, 0x09	; 9
 3e6:	2f 70       	andi	r18, 0x0F	; 15
 3e8:	89 2f       	mov	r24, r25
 3ea:	82 95       	swap	r24
 3ec:	80 7f       	andi	r24, 0xF0	; 240
 3ee:	41 98       	cbi	0x08, 1	; 8
 3f0:	82 2b       	or	r24, r18
 3f2:	08 95       	ret

000003f4 <lcd_waitbusy>:
 3f4:	80 e0       	ldi	r24, 0x00	; 0
 3f6:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <lcd_read>
 3fa:	88 23       	and	r24, r24
 3fc:	dc f3       	brlt	.-10     	; 0x3f4 <lcd_waitbusy>
 3fe:	85 e1       	ldi	r24, 0x15	; 21
 400:	8a 95       	dec	r24
 402:	f1 f7       	brne	.-4      	; 0x400 <__LOCK_REGION_LENGTH__>
 404:	00 00       	nop
 406:	80 e0       	ldi	r24, 0x00	; 0
 408:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <lcd_read>
 40c:	08 95       	ret

0000040e <lcd_command>:
 40e:	cf 93       	push	r28
 410:	c8 2f       	mov	r28, r24
 412:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <lcd_waitbusy>
 416:	60 e0       	ldi	r22, 0x00	; 0
 418:	8c 2f       	mov	r24, r28
 41a:	0e 94 ba 01 	call	0x374	; 0x374 <lcd_write>
 41e:	cf 91       	pop	r28
 420:	08 95       	ret

00000422 <lcd_gotoxy>:
 422:	61 11       	cpse	r22, r1
 424:	04 c0       	rjmp	.+8      	; 0x42e <lcd_gotoxy+0xc>
 426:	80 58       	subi	r24, 0x80	; 128
 428:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
 42c:	08 95       	ret
 42e:	80 54       	subi	r24, 0x40	; 64
 430:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
 434:	08 95       	ret

00000436 <lcd_clrscr>:
 436:	81 e0       	ldi	r24, 0x01	; 1
 438:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
 43c:	08 95       	ret

0000043e <lcd_home>:
 43e:	82 e0       	ldi	r24, 0x02	; 2
 440:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
 444:	08 95       	ret

00000446 <lcd_putc>:
 446:	cf 93       	push	r28
 448:	c8 2f       	mov	r28, r24
 44a:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <lcd_waitbusy>
 44e:	ca 30       	cpi	r28, 0x0A	; 10
 450:	49 f4       	brne	.+18     	; 0x464 <lcd_putc+0x1e>
 452:	80 34       	cpi	r24, 0x40	; 64
 454:	10 f0       	brcs	.+4      	; 0x45a <lcd_putc+0x14>
 456:	80 e0       	ldi	r24, 0x00	; 0
 458:	01 c0       	rjmp	.+2      	; 0x45c <lcd_putc+0x16>
 45a:	80 e4       	ldi	r24, 0x40	; 64
 45c:	80 58       	subi	r24, 0x80	; 128
 45e:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
 462:	04 c0       	rjmp	.+8      	; 0x46c <lcd_putc+0x26>
 464:	61 e0       	ldi	r22, 0x01	; 1
 466:	8c 2f       	mov	r24, r28
 468:	0e 94 ba 01 	call	0x374	; 0x374 <lcd_write>
 46c:	cf 91       	pop	r28
 46e:	08 95       	ret

00000470 <lcd_puts>:
 470:	cf 93       	push	r28
 472:	df 93       	push	r29
 474:	ec 01       	movw	r28, r24
 476:	21 96       	adiw	r28, 0x01	; 1
 478:	fc 01       	movw	r30, r24
 47a:	80 81       	ld	r24, Z
 47c:	88 23       	and	r24, r24
 47e:	29 f0       	breq	.+10     	; 0x48a <lcd_puts+0x1a>
 480:	0e 94 23 02 	call	0x446	; 0x446 <lcd_putc>
 484:	89 91       	ld	r24, Y+
 486:	81 11       	cpse	r24, r1
 488:	fb cf       	rjmp	.-10     	; 0x480 <lcd_puts+0x10>
 48a:	df 91       	pop	r29
 48c:	cf 91       	pop	r28
 48e:	08 95       	ret

00000490 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 490:	cf 93       	push	r28
 492:	c8 2f       	mov	r28, r24
    }
    else if ( ( &LCD_DATA0_PORT == &LCD_DATA1_PORT) && ( &LCD_DATA1_PORT == &LCD_DATA2_PORT ) && ( &LCD_DATA2_PORT == &LCD_DATA3_PORT )
           && (LCD_DATA0_PIN == 0 ) && (LCD_DATA1_PIN == 1) && (LCD_DATA2_PIN == 2) && (LCD_DATA3_PIN == 3) )
    {
        /* configure all port bits as output (all LCD data lines on same port, but control lines on different ports) */
        DDR(LCD_DATA0_PORT) |= 0x0F;
 494:	8a b1       	in	r24, 0x0a	; 10
 496:	8f 60       	ori	r24, 0x0F	; 15
 498:	8a b9       	out	0x0a, r24	; 10
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
 49a:	3b 9a       	sbi	0x07, 3	; 7
        DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
 49c:	3a 9a       	sbi	0x07, 2	; 7
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
 49e:	39 9a       	sbi	0x07, 1	; 7
 4a0:	8f ef       	ldi	r24, 0xFF	; 255
 4a2:	99 ef       	ldi	r25, 0xF9	; 249
 4a4:	01 97       	sbiw	r24, 0x01	; 1
 4a6:	f1 f7       	brne	.-4      	; 0x4a4 <lcd_init+0x14>
 4a8:	00 c0       	rjmp	.+0      	; 0x4aa <lcd_init+0x1a>
 4aa:	00 00       	nop
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    }
    delay(LCD_DELAY_BOOTUP);             /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);    // LCD_FUNCTION>>4;
 4ac:	59 9a       	sbi	0x0b, 1	; 11
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);    // LCD_FUNCTION_8BIT>>4;
 4ae:	58 9a       	sbi	0x0b, 0	; 11
    lcd_e_toggle();
 4b0:	0e 94 b3 01 	call	0x366	; 0x366 <toggle_e>
 4b4:	8f e1       	ldi	r24, 0x1F	; 31
 4b6:	9e e4       	ldi	r25, 0x4E	; 78
 4b8:	01 97       	sbiw	r24, 0x01	; 1
 4ba:	f1 f7       	brne	.-4      	; 0x4b8 <lcd_init+0x28>
 4bc:	00 c0       	rjmp	.+0      	; 0x4be <lcd_init+0x2e>
 4be:	00 00       	nop
    delay(LCD_DELAY_INIT);               /* delay, busy flag can't be checked here */
   
    /* repeat last command */ 
    lcd_e_toggle();      
 4c0:	0e 94 b3 01 	call	0x366	; 0x366 <toggle_e>
 4c4:	8f ef       	ldi	r24, 0xFF	; 255
 4c6:	90 e0       	ldi	r25, 0x00	; 0
 4c8:	01 97       	sbiw	r24, 0x01	; 1
 4ca:	f1 f7       	brne	.-4      	; 0x4c8 <lcd_init+0x38>
 4cc:	00 c0       	rjmp	.+0      	; 0x4ce <lcd_init+0x3e>
 4ce:	00 00       	nop
    delay(LCD_DELAY_INIT_REP);           /* delay, busy flag can't be checked here */
    
    /* repeat last command a third time */
    lcd_e_toggle();      
 4d0:	0e 94 b3 01 	call	0x366	; 0x366 <toggle_e>
 4d4:	8f ef       	ldi	r24, 0xFF	; 255
 4d6:	90 e0       	ldi	r25, 0x00	; 0
 4d8:	01 97       	sbiw	r24, 0x01	; 1
 4da:	f1 f7       	brne	.-4      	; 0x4d8 <lcd_init+0x48>
 4dc:	00 c0       	rjmp	.+0      	; 0x4de <lcd_init+0x4e>
 4de:	00 00       	nop
    delay(LCD_DELAY_INIT_REP);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
 4e0:	58 98       	cbi	0x0b, 0	; 11
    lcd_e_toggle();
 4e2:	0e 94 b3 01 	call	0x366	; 0x366 <toggle_e>
 4e6:	8f ef       	ldi	r24, 0xFF	; 255
 4e8:	90 e0       	ldi	r25, 0x00	; 0
 4ea:	01 97       	sbiw	r24, 0x01	; 1
 4ec:	f1 f7       	brne	.-4      	; 0x4ea <lcd_init+0x5a>
 4ee:	00 c0       	rjmp	.+0      	; 0x4f0 <lcd_init+0x60>
 4f0:	00 00       	nop
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
	lcd_command(KS0073_4LINES_MODE);
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
 4f2:	88 e2       	ldi	r24, 0x28	; 40
 4f4:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
 4f8:	88 e0       	ldi	r24, 0x08	; 8
 4fa:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
 4fe:	0e 94 1b 02 	call	0x436	; 0x436 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 502:	86 e0       	ldi	r24, 0x06	; 6
 504:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
 508:	8c 2f       	mov	r24, r28
 50a:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>

}/* lcd_init */
 50e:	cf 91       	pop	r28
 510:	08 95       	ret

00000512 <main>:
#define SET_TIME_ON_START 1

#define LED PD4

int main() 
{
 512:	cf 93       	push	r28
 514:	df 93       	push	r29
 516:	cd b7       	in	r28, 0x3d	; 61
 518:	de b7       	in	r29, 0x3e	; 62
 51a:	c6 55       	subi	r28, 0x56	; 86
 51c:	d1 09       	sbc	r29, r1
 51e:	0f b6       	in	r0, 0x3f	; 63
 520:	f8 94       	cli
 522:	de bf       	out	0x3e, r29	; 62
 524:	0f be       	out	0x3f, r0	; 63
 526:	cd bf       	out	0x3d, r28	; 61
    rtc_t rtc;
	
	BIT_SET(DDRD,LED);
 528:	54 9a       	sbi	0x0a, 4	; 10
	BIT_SET(PORTD,LED);
 52a:	5c 9a       	sbi	0x0b, 4	; 11
	
	lcd_init(LCD_DISP_ON_CURSOR);		
 52c:	8e e0       	ldi	r24, 0x0E	; 14
 52e:	0e 94 48 02 	call	0x490	; 0x490 <lcd_init>
		
	lcd_clrscr();             /* clear screen of lcd */
 532:	0e 94 1b 02 	call	0x436	; 0x436 <lcd_clrscr>
	lcd_home();               /* bring cursor to 0,0 */
 536:	0e 94 1f 02 	call	0x43e	; 0x43e <lcd_home>
	lcd_puts("    Welcome");        /* type something random */
 53a:	80 e0       	ldi	r24, 0x00	; 0
 53c:	91 e0       	ldi	r25, 0x01	; 1
 53e:	0e 94 38 02 	call	0x470	; 0x470 <lcd_puts>
	lcd_gotoxy(0,1);          /* go to 2nd row 1st col */
 542:	61 e0       	ldi	r22, 0x01	; 1
 544:	80 e0       	ldi	r24, 0x00	; 0
 546:	0e 94 11 02 	call	0x422	; 0x422 <lcd_gotoxy>
	lcd_puts("  Latmos Ltd");  /* type something random */
 54a:	8c e0       	ldi	r24, 0x0C	; 12
 54c:	91 e0       	ldi	r25, 0x01	; 1
 54e:	0e 94 38 02 	call	0x470	; 0x470 <lcd_puts>
	lcd_command(LCD_DISP_ON);
 552:	8c e0       	ldi	r24, 0x0C	; 12
 554:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 558:	2f ef       	ldi	r18, 0xFF	; 255
 55a:	8b e7       	ldi	r24, 0x7B	; 123
 55c:	92 e9       	ldi	r25, 0x92	; 146
 55e:	21 50       	subi	r18, 0x01	; 1
 560:	80 40       	sbci	r24, 0x00	; 0
 562:	90 40       	sbci	r25, 0x00	; 0
 564:	e1 f7       	brne	.-8      	; 0x55e <main+0x4c>
 566:	00 c0       	rjmp	.+0      	; 0x568 <main+0x56>
 568:	00 00       	nop
		   Upper nibble: X
			 Lower nibble: Y
			 Register: XY
			 e.g rtc.min=48 => X = 4, Y = 8 */    
    
	RTC_Init();
 56a:	0e 94 05 04 	call	0x80a	; 0x80a <RTC_Init>
		
		/* Set time only once and then disable the following code*/
	#if SET_TIME_ON_START
				
		rtc.hour = 0x20; //  10:40:20 am
 56e:	80 e2       	ldi	r24, 0x20	; 32
 570:	8b 83       	std	Y+3, r24	; 0x03
		rtc.min =  0x22;
 572:	82 e2       	ldi	r24, 0x22	; 34
 574:	8a 83       	std	Y+2, r24	; 0x02
		rtc.sec =  0x00;
 576:	19 82       	std	Y+1, r1	; 0x01

		rtc.date = 0x15; //1st Jan 2016
 578:	85 e1       	ldi	r24, 0x15	; 21
 57a:	8d 83       	std	Y+5, r24	; 0x05
		rtc.month = 0x05;
 57c:	85 e0       	ldi	r24, 0x05	; 5
 57e:	8e 83       	std	Y+6, r24	; 0x06
		rtc.year = 0x18;
 580:	88 e1       	ldi	r24, 0x18	; 24
 582:	8f 83       	std	Y+7, r24	; 0x07
		rtc.weekDay = 2; // Friday: 5th day of week considering monday as first day.
 584:	82 e0       	ldi	r24, 0x02	; 2
 586:	8c 83       	std	Y+4, r24	; 0x04
		/*##### Set the time and Date only once. Once the Time and Date is set, comment these lines
					and reflash the code. Else the time will be set every time the controller is reset*/
		RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
 588:	ce 01       	movw	r24, r28
 58a:	01 96       	adiw	r24, 0x01	; 1
 58c:	0e 94 15 04 	call	0x82a	; 0x82a <RTC_SetDateTime>
		char min[3];
		char hour[3];
		char date[3];
		char month[3];
		char year[5];
		sprintf(sec,"%02x", (uint8_t)rtc.sec);
 590:	ce 01       	movw	r24, r28
 592:	8a 5b       	subi	r24, 0xBA	; 186
 594:	9f 4f       	sbci	r25, 0xFF	; 255
 596:	2f 96       	adiw	r28, 0x0f	; 15
 598:	9f af       	std	Y+63, r25	; 0x3f
 59a:	8e af       	std	Y+62, r24	; 0x3e
 59c:	2f 97       	sbiw	r28, 0x0f	; 15
		sprintf(min,"%02x", (uint8_t)rtc.min);
 59e:	3e 01       	movw	r6, r28
 5a0:	93 e4       	ldi	r25, 0x43	; 67
 5a2:	69 0e       	add	r6, r25
 5a4:	71 1c       	adc	r7, r1
		sprintf(hour,"%02x", (uint8_t)rtc.hour);
 5a6:	4e 01       	movw	r8, r28
 5a8:	20 e4       	ldi	r18, 0x40	; 64
 5aa:	82 0e       	add	r8, r18
 5ac:	91 1c       	adc	r9, r1
		sprintf(date,"%02x", (uint8_t)rtc.date);
 5ae:	5e 01       	movw	r10, r28
 5b0:	8d e3       	ldi	r24, 0x3D	; 61
 5b2:	a8 0e       	add	r10, r24
 5b4:	b1 1c       	adc	r11, r1
		sprintf(month,"%02x", (uint8_t)rtc.month);
 5b6:	2e 01       	movw	r4, r28
 5b8:	9a e3       	ldi	r25, 0x3A	; 58
 5ba:	49 0e       	add	r4, r25
 5bc:	51 1c       	adc	r5, r1
		sprintf(year,"20%02x", (uint8_t)rtc.year);
 5be:	1e 01       	movw	r2, r28
 5c0:	2d e2       	ldi	r18, 0x2D	; 45
 5c2:	22 0e       	add	r2, r18
 5c4:	31 1c       	adc	r3, r1
				
		char temp_hum[20];
		char temp[4];
		char hum[4];
		sprintf(temp, "%d", temperature);
 5c6:	ce 01       	movw	r24, r28
 5c8:	c6 96       	adiw	r24, 0x36	; 54
 5ca:	61 96       	adiw	r28, 0x11	; 17
 5cc:	9f af       	std	Y+63, r25	; 0x3f
 5ce:	8e af       	std	Y+62, r24	; 0x3e
 5d0:	61 97       	sbiw	r28, 0x11	; 17
		sprintf(hum, "%d", humidity);
 5d2:	04 97       	sbiw	r24, 0x04	; 4
 5d4:	63 96       	adiw	r28, 0x13	; 19
 5d6:	9f af       	std	Y+63, r25	; 0x3f
 5d8:	8e af       	std	Y+62, r24	; 0x3e
 5da:	63 97       	sbiw	r28, 0x13	; 19
		sprintf(temp_hum, "  T=%sC  H=%s%%", temp, hum);
 5dc:	8a 97       	sbiw	r24, 0x2a	; 42
 5de:	65 96       	adiw	r28, 0x15	; 21
 5e0:	9f af       	std	Y+63, r25	; 0x3f
 5e2:	8e af       	std	Y+62, r24	; 0x3e
 5e4:	65 97       	sbiw	r28, 0x15	; 21
				
		char date_time[17];
		sprintf(date_time, "%s/%s/%s %s:%s", date, month, year, hour, min);
 5e6:	44 96       	adiw	r24, 0x14	; 20
 5e8:	67 96       	adiw	r28, 0x17	; 23
 5ea:	9f af       	std	Y+63, r25	; 0x3f
 5ec:	8e af       	std	Y+62, r24	; 0x3e
 5ee:	67 97       	sbiw	r28, 0x17	; 23
		RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
	#endif
		
    while(1)
    {
		int temperature = 0, humidity = 0;
 5f0:	2d 96       	adiw	r28, 0x0d	; 13
 5f2:	1f ae       	std	Y+63, r1	; 0x3f
 5f4:	1e ae       	std	Y+62, r1	; 0x3e
 5f6:	2d 97       	sbiw	r28, 0x0d	; 13
 5f8:	2b 96       	adiw	r28, 0x0b	; 11
 5fa:	1f ae       	std	Y+63, r1	; 0x3f
 5fc:	1e ae       	std	Y+62, r1	; 0x3e
 5fe:	2b 97       	sbiw	r28, 0x0b	; 11
				
        RTC_GetDateTime(&rtc);
 600:	ce 01       	movw	r24, r28
 602:	01 96       	adiw	r24, 0x01	; 1
 604:	0e 94 3a 04 	call	0x874	; 0x874 <RTC_GetDateTime>
				
		dhtxxconvert(DHTXX_DHT22, &DHT_PORT, &DHT_DDR, &DHT_PIN, ( 1 << DHT_DATA_PIN ) );  //	Start conversion
 608:	00 e2       	ldi	r16, 0x20	; 32
 60a:	29 e2       	ldi	r18, 0x29	; 41
 60c:	30 e0       	ldi	r19, 0x00	; 0
 60e:	4a e2       	ldi	r20, 0x2A	; 42
 610:	50 e0       	ldi	r21, 0x00	; 0
 612:	6b e2       	ldi	r22, 0x2B	; 43
 614:	70 e0       	ldi	r23, 0x00	; 0
 616:	81 e0       	ldi	r24, 0x01	; 1
 618:	0e 94 42 01 	call	0x284	; 0x284 <dhtxxconvert>
 61c:	9f ef       	ldi	r25, 0xFF	; 255
 61e:	23 ed       	ldi	r18, 0xD3	; 211
 620:	80 e3       	ldi	r24, 0x30	; 48
 622:	91 50       	subi	r25, 0x01	; 1
 624:	20 40       	sbci	r18, 0x00	; 0
 626:	80 40       	sbci	r24, 0x00	; 0
 628:	e1 f7       	brne	.-8      	; 0x622 <main+0x110>
 62a:	00 c0       	rjmp	.+0      	; 0x62c <main+0x11a>
 62c:	00 00       	nop
		_delay_ms(1000);
		dhtxxread(DHTXX_DHT22, &DHT_PORT, &DHT_DDR, &DHT_PIN, ( 1 << DHT_DATA_PIN ), &temperature, &humidity ); // Get values
 62e:	ce 01       	movw	r24, r28
 630:	87 5b       	subi	r24, 0xB7	; 183
 632:	9f 4f       	sbci	r25, 0xFF	; 255
 634:	6c 01       	movw	r12, r24
 636:	02 96       	adiw	r24, 0x02	; 2
 638:	7c 01       	movw	r14, r24
 63a:	29 e2       	ldi	r18, 0x29	; 41
 63c:	30 e0       	ldi	r19, 0x00	; 0
 63e:	4a e2       	ldi	r20, 0x2A	; 42
 640:	50 e0       	ldi	r21, 0x00	; 0
 642:	6b e2       	ldi	r22, 0x2B	; 43
 644:	70 e0       	ldi	r23, 0x00	; 0
 646:	81 e0       	ldi	r24, 0x01	; 1
 648:	0e 94 4b 00 	call	0x96	; 0x96 <dhtxxread>
		temperature /= 10;
 64c:	2d 96       	adiw	r28, 0x0d	; 13
 64e:	8e ad       	ldd	r24, Y+62	; 0x3e
 650:	9f ad       	ldd	r25, Y+63	; 0x3f
 652:	2d 97       	sbiw	r28, 0x0d	; 13
 654:	2a e0       	ldi	r18, 0x0A	; 10
 656:	30 e0       	ldi	r19, 0x00	; 0
 658:	b9 01       	movw	r22, r18
 65a:	0e 94 6d 04 	call	0x8da	; 0x8da <__divmodhi4>
 65e:	2d 96       	adiw	r28, 0x0d	; 13
 660:	7f af       	std	Y+63, r23	; 0x3f
 662:	6e af       	std	Y+62, r22	; 0x3e
 664:	2d 97       	sbiw	r28, 0x0d	; 13
		humidity /= 10;
 666:	2b 96       	adiw	r28, 0x0b	; 11
 668:	8e ad       	ldd	r24, Y+62	; 0x3e
 66a:	9f ad       	ldd	r25, Y+63	; 0x3f
 66c:	2b 97       	sbiw	r28, 0x0b	; 11
 66e:	b9 01       	movw	r22, r18
 670:	0e 94 6d 04 	call	0x8da	; 0x8da <__divmodhi4>
 674:	2b 96       	adiw	r28, 0x0b	; 11
 676:	7f af       	std	Y+63, r23	; 0x3f
 678:	6e af       	std	Y+62, r22	; 0x3e
 67a:	2b 97       	sbiw	r28, 0x0b	; 11
		char min[3];
		char hour[3];
		char date[3];
		char month[3];
		char year[5];
		sprintf(sec,"%02x", (uint8_t)rtc.sec);
 67c:	89 81       	ldd	r24, Y+1	; 0x01
 67e:	1f 92       	push	r1
 680:	8f 93       	push	r24
 682:	0b e1       	ldi	r16, 0x1B	; 27
 684:	11 e0       	ldi	r17, 0x01	; 1
 686:	1f 93       	push	r17
 688:	0f 93       	push	r16
 68a:	2f 96       	adiw	r28, 0x0f	; 15
 68c:	9f ad       	ldd	r25, Y+63	; 0x3f
 68e:	2f 97       	sbiw	r28, 0x0f	; 15
 690:	9f 93       	push	r25
 692:	2e 96       	adiw	r28, 0x0e	; 14
 694:	2f ad       	ldd	r18, Y+63	; 0x3f
 696:	2e 97       	sbiw	r28, 0x0e	; 14
 698:	2f 93       	push	r18
 69a:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		sprintf(min,"%02x", (uint8_t)rtc.min);
 69e:	8a 81       	ldd	r24, Y+2	; 0x02
 6a0:	1f 92       	push	r1
 6a2:	8f 93       	push	r24
 6a4:	1f 93       	push	r17
 6a6:	0f 93       	push	r16
 6a8:	7f 92       	push	r7
 6aa:	6f 92       	push	r6
 6ac:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		sprintf(hour,"%02x", (uint8_t)rtc.hour);
 6b0:	8b 81       	ldd	r24, Y+3	; 0x03
 6b2:	1f 92       	push	r1
 6b4:	8f 93       	push	r24
 6b6:	1f 93       	push	r17
 6b8:	0f 93       	push	r16
 6ba:	9f 92       	push	r9
 6bc:	8f 92       	push	r8
 6be:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		sprintf(date,"%02x", (uint8_t)rtc.date);
 6c2:	8d 81       	ldd	r24, Y+5	; 0x05
 6c4:	1f 92       	push	r1
 6c6:	8f 93       	push	r24
 6c8:	1f 93       	push	r17
 6ca:	0f 93       	push	r16
 6cc:	bf 92       	push	r11
 6ce:	af 92       	push	r10
 6d0:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		sprintf(month,"%02x", (uint8_t)rtc.month);
 6d4:	8e 81       	ldd	r24, Y+6	; 0x06
 6d6:	1f 92       	push	r1
 6d8:	8f 93       	push	r24
 6da:	1f 93       	push	r17
 6dc:	0f 93       	push	r16
 6de:	5f 92       	push	r5
 6e0:	4f 92       	push	r4
 6e2:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		sprintf(year,"20%02x", (uint8_t)rtc.year);
 6e6:	8f 81       	ldd	r24, Y+7	; 0x07
 6e8:	1f 92       	push	r1
 6ea:	8f 93       	push	r24
 6ec:	89 e1       	ldi	r24, 0x19	; 25
 6ee:	91 e0       	ldi	r25, 0x01	; 1
 6f0:	9f 93       	push	r25
 6f2:	8f 93       	push	r24
 6f4:	3f 92       	push	r3
 6f6:	2f 92       	push	r2
 6f8:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
				
		char temp_hum[20];
		char temp[4];
		char hum[4];
		sprintf(temp, "%d", temperature);
 6fc:	0f b6       	in	r0, 0x3f	; 63
 6fe:	f8 94       	cli
 700:	de bf       	out	0x3e, r29	; 62
 702:	0f be       	out	0x3f, r0	; 63
 704:	cd bf       	out	0x3d, r28	; 61
 706:	2d 96       	adiw	r28, 0x0d	; 13
 708:	8f ad       	ldd	r24, Y+63	; 0x3f
 70a:	2d 97       	sbiw	r28, 0x0d	; 13
 70c:	8f 93       	push	r24
 70e:	2c 96       	adiw	r28, 0x0c	; 12
 710:	8f ad       	ldd	r24, Y+63	; 0x3f
 712:	2c 97       	sbiw	r28, 0x0c	; 12
 714:	8f 93       	push	r24
 716:	00 e2       	ldi	r16, 0x20	; 32
 718:	11 e0       	ldi	r17, 0x01	; 1
 71a:	1f 93       	push	r17
 71c:	0f 93       	push	r16
 71e:	61 96       	adiw	r28, 0x11	; 17
 720:	9f ad       	ldd	r25, Y+63	; 0x3f
 722:	61 97       	sbiw	r28, 0x11	; 17
 724:	9f 93       	push	r25
 726:	60 96       	adiw	r28, 0x10	; 16
 728:	2f ad       	ldd	r18, Y+63	; 0x3f
 72a:	60 97       	sbiw	r28, 0x10	; 16
 72c:	2f 93       	push	r18
 72e:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		sprintf(hum, "%d", humidity);
 732:	2b 96       	adiw	r28, 0x0b	; 11
 734:	8f ad       	ldd	r24, Y+63	; 0x3f
 736:	2b 97       	sbiw	r28, 0x0b	; 11
 738:	8f 93       	push	r24
 73a:	2a 96       	adiw	r28, 0x0a	; 10
 73c:	8f ad       	ldd	r24, Y+63	; 0x3f
 73e:	2a 97       	sbiw	r28, 0x0a	; 10
 740:	8f 93       	push	r24
 742:	1f 93       	push	r17
 744:	0f 93       	push	r16
 746:	63 96       	adiw	r28, 0x13	; 19
 748:	8f ad       	ldd	r24, Y+63	; 0x3f
 74a:	63 97       	sbiw	r28, 0x13	; 19
 74c:	8f 93       	push	r24
 74e:	62 96       	adiw	r28, 0x12	; 18
 750:	9f ad       	ldd	r25, Y+63	; 0x3f
 752:	62 97       	sbiw	r28, 0x12	; 18
 754:	9f 93       	push	r25
 756:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		sprintf(temp_hum, "  T=%sC  H=%s%%", temp, hum);
 75a:	63 96       	adiw	r28, 0x13	; 19
 75c:	2f ad       	ldd	r18, Y+63	; 0x3f
 75e:	63 97       	sbiw	r28, 0x13	; 19
 760:	2f 93       	push	r18
 762:	62 96       	adiw	r28, 0x12	; 18
 764:	8f ad       	ldd	r24, Y+63	; 0x3f
 766:	62 97       	sbiw	r28, 0x12	; 18
 768:	8f 93       	push	r24
 76a:	61 96       	adiw	r28, 0x11	; 17
 76c:	9f ad       	ldd	r25, Y+63	; 0x3f
 76e:	61 97       	sbiw	r28, 0x11	; 17
 770:	9f 93       	push	r25
 772:	60 96       	adiw	r28, 0x10	; 16
 774:	2f ad       	ldd	r18, Y+63	; 0x3f
 776:	60 97       	sbiw	r28, 0x10	; 16
 778:	2f 93       	push	r18
 77a:	83 e2       	ldi	r24, 0x23	; 35
 77c:	91 e0       	ldi	r25, 0x01	; 1
 77e:	9f 93       	push	r25
 780:	8f 93       	push	r24
 782:	65 96       	adiw	r28, 0x15	; 21
 784:	8f ad       	ldd	r24, Y+63	; 0x3f
 786:	65 97       	sbiw	r28, 0x15	; 21
 788:	8f 93       	push	r24
 78a:	64 96       	adiw	r28, 0x14	; 20
 78c:	9f ad       	ldd	r25, Y+63	; 0x3f
 78e:	64 97       	sbiw	r28, 0x14	; 20
 790:	9f 93       	push	r25
 792:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
				
		char date_time[17];
		sprintf(date_time, "%s/%s/%s %s:%s", date, month, year, hour, min);
 796:	7f 92       	push	r7
 798:	6f 92       	push	r6
 79a:	9f 92       	push	r9
 79c:	8f 92       	push	r8
 79e:	3f 92       	push	r3
 7a0:	2f 92       	push	r2
 7a2:	5f 92       	push	r5
 7a4:	4f 92       	push	r4
 7a6:	bf 92       	push	r11
 7a8:	af 92       	push	r10
 7aa:	83 e3       	ldi	r24, 0x33	; 51
 7ac:	91 e0       	ldi	r25, 0x01	; 1
 7ae:	9f 93       	push	r25
 7b0:	8f 93       	push	r24
 7b2:	67 96       	adiw	r28, 0x17	; 23
 7b4:	2f ad       	ldd	r18, Y+63	; 0x3f
 7b6:	67 97       	sbiw	r28, 0x17	; 23
 7b8:	2f 93       	push	r18
 7ba:	66 96       	adiw	r28, 0x16	; 22
 7bc:	8f ad       	ldd	r24, Y+63	; 0x3f
 7be:	66 97       	sbiw	r28, 0x16	; 22
 7c0:	8f 93       	push	r24
 7c2:	0e 94 95 04 	call	0x92a	; 0x92a <sprintf>
		lcd_clrscr();             /* clear screen of lcd */
 7c6:	0f b6       	in	r0, 0x3f	; 63
 7c8:	f8 94       	cli
 7ca:	de bf       	out	0x3e, r29	; 62
 7cc:	0f be       	out	0x3f, r0	; 63
 7ce:	cd bf       	out	0x3d, r28	; 61
 7d0:	0e 94 1b 02 	call	0x436	; 0x436 <lcd_clrscr>
		lcd_home();               /* bring cursor to 0,0 */
 7d4:	0e 94 1f 02 	call	0x43e	; 0x43e <lcd_home>
		lcd_puts(date_time);			/* datetime */
 7d8:	ce 01       	movw	r24, r28
 7da:	4c 96       	adiw	r24, 0x1c	; 28
 7dc:	0e 94 38 02 	call	0x470	; 0x470 <lcd_puts>
		lcd_gotoxy(0,1);          /* go to 2nd row 1st col */
 7e0:	61 e0       	ldi	r22, 0x01	; 1
 7e2:	80 e0       	ldi	r24, 0x00	; 0
 7e4:	0e 94 11 02 	call	0x422	; 0x422 <lcd_gotoxy>
		lcd_puts(temp_hum);				/* print Temperature and Humidity*/
 7e8:	ce 01       	movw	r24, r28
 7ea:	08 96       	adiw	r24, 0x08	; 8
 7ec:	0e 94 38 02 	call	0x470	; 0x470 <lcd_puts>
		lcd_command(LCD_DISP_ON);
 7f0:	8c e0       	ldi	r24, 0x0C	; 12
 7f2:	0e 94 07 02 	call	0x40e	; 0x40e <lcd_command>
 7f6:	9f ef       	ldi	r25, 0xFF	; 255
 7f8:	23 ed       	ldi	r18, 0xD3	; 211
 7fa:	80 e3       	ldi	r24, 0x30	; 48
 7fc:	91 50       	subi	r25, 0x01	; 1
 7fe:	20 40       	sbci	r18, 0x00	; 0
 800:	80 40       	sbci	r24, 0x00	; 0
 802:	e1 f7       	brne	.-8      	; 0x7fc <main+0x2ea>
 804:	00 c0       	rjmp	.+0      	; 0x806 <main+0x2f4>
 806:	00 00       	nop
 808:	f3 ce       	rjmp	.-538    	; 0x5f0 <main+0xde>

0000080a <RTC_Init>:

 * description :This function is used to Initialize the Ds1307 RTC.
***************************************************************************************************/
void RTC_Init(void)
{
    I2C_Init();                             // Initialize the I2c module.
 80a:	0e 94 7d 01 	call	0x2fa	; 0x2fa <I2C_Init>
    I2C_Start();                            // Start I2C communication
 80e:	0e 94 86 01 	call	0x30c	; 0x30c <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
 812:	80 ed       	ldi	r24, 0xD0	; 208
 814:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
 818:	87 e0       	ldi	r24, 0x07	; 7
 81a:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>

    I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
 81e:	80 e0       	ldi	r24, 0x00	; 0
 820:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>

    I2C_Stop();                             // Stop I2C communication after initializing DS1307
 824:	0e 94 8f 01 	call	0x31e	; 0x31e <I2C_Stop>
 828:	08 95       	ret

0000082a <RTC_SetDateTime>:
        Note: The date and time should be of BCD format, 
             like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
                  0x15,0x08,0x47 for 15th day,8th month and 47th year.                 
***************************************************************************************************/
void RTC_SetDateTime(rtc_t *rtc)
{
 82a:	cf 93       	push	r28
 82c:	df 93       	push	r29
 82e:	ec 01       	movw	r28, r24
    I2C_Start();                          // Start I2C communication
 830:	0e 94 86 01 	call	0x30c	; 0x30c <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);      // connect to DS1307 by sending its ID on I2c Bus
 834:	80 ed       	ldi	r24, 0xD0	; 208
 836:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request sec RAM address at 00H
 83a:	80 e0       	ldi	r24, 0x00	; 0
 83c:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>

    I2C_Write(rtc->sec);                    // Write sec from RAM address 00H
 840:	88 81       	ld	r24, Y
 842:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(rtc->min);                    // Write min from RAM address 01H
 846:	89 81       	ldd	r24, Y+1	; 0x01
 848:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(rtc->hour);                    // Write hour from RAM address 02H
 84c:	8a 81       	ldd	r24, Y+2	; 0x02
 84e:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
 852:	8b 81       	ldd	r24, Y+3	; 0x03
 854:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
 858:	8c 81       	ldd	r24, Y+4	; 0x04
 85a:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
 85e:	8d 81       	ldd	r24, Y+5	; 0x05
 860:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(rtc->year);                    // Write year on RAM address 06h
 864:	8e 81       	ldd	r24, Y+6	; 0x06
 866:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>

    I2C_Stop();                              // Stop I2C communication after Setting the Date
 86a:	0e 94 8f 01 	call	0x31e	; 0x31e <I2C_Stop>
}
 86e:	df 91       	pop	r29
 870:	cf 91       	pop	r28
 872:	08 95       	ret

00000874 <RTC_GetDateTime>:
    Note: The date and time read from Ds1307 will be of BCD format, 
          like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
               0x15,0x08,0x47 for 15th day,8th month and 47th year.              
***************************************************************************************************/
void RTC_GetDateTime(rtc_t *rtc)
{
 874:	cf 93       	push	r28
 876:	df 93       	push	r29
 878:	ec 01       	movw	r28, r24
    I2C_Start();                            // Start I2C communication
 87a:	0e 94 86 01 	call	0x30c	; 0x30c <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
 87e:	80 ed       	ldi	r24, 0xD0	; 208
 880:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
 884:	80 e0       	ldi	r24, 0x00	; 0
 886:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>

    I2C_Stop();                                // Stop I2C communication after selecting Sec Register
 88a:	0e 94 8f 01 	call	0x31e	; 0x31e <I2C_Stop>

    I2C_Start();                            // Start I2C communication
 88e:	0e 94 86 01 	call	0x30c	; 0x30c <I2C_Start>
    I2C_Write(C_Ds1307ReadMode_U8);            // connect to DS1307(Read mode) by sending its ID
 892:	81 ed       	ldi	r24, 0xD1	; 209
 894:	0e 94 99 01 	call	0x332	; 0x332 <I2C_Write>

    rtc->sec = I2C_Read(1);                // read second and return Positive ACK
 898:	81 e0       	ldi	r24, 0x01	; 1
 89a:	0e 94 a4 01 	call	0x348	; 0x348 <I2C_Read>
 89e:	88 83       	st	Y, r24
    rtc->min = I2C_Read(1);                 // read minute and return Positive ACK
 8a0:	81 e0       	ldi	r24, 0x01	; 1
 8a2:	0e 94 a4 01 	call	0x348	; 0x348 <I2C_Read>
 8a6:	89 83       	std	Y+1, r24	; 0x01
    rtc->hour= I2C_Read(1);               // read hour and return Negative/No ACK
 8a8:	81 e0       	ldi	r24, 0x01	; 1
 8aa:	0e 94 a4 01 	call	0x348	; 0x348 <I2C_Read>
 8ae:	8a 83       	std	Y+2, r24	; 0x02
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
 8b0:	81 e0       	ldi	r24, 0x01	; 1
 8b2:	0e 94 a4 01 	call	0x348	; 0x348 <I2C_Read>
 8b6:	8b 83       	std	Y+3, r24	; 0x03
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
 8b8:	81 e0       	ldi	r24, 0x01	; 1
 8ba:	0e 94 a4 01 	call	0x348	; 0x348 <I2C_Read>
 8be:	8c 83       	std	Y+4, r24	; 0x04
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
 8c0:	81 e0       	ldi	r24, 0x01	; 1
 8c2:	0e 94 a4 01 	call	0x348	; 0x348 <I2C_Read>
 8c6:	8d 83       	std	Y+5, r24	; 0x05
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK
 8c8:	80 e0       	ldi	r24, 0x00	; 0
 8ca:	0e 94 a4 01 	call	0x348	; 0x348 <I2C_Read>
 8ce:	8e 83       	std	Y+6, r24	; 0x06

    I2C_Stop();                              // Stop I2C communication after reading the Date
 8d0:	0e 94 8f 01 	call	0x31e	; 0x31e <I2C_Stop>
}
 8d4:	df 91       	pop	r29
 8d6:	cf 91       	pop	r28
 8d8:	08 95       	ret

000008da <__divmodhi4>:
 8da:	97 fb       	bst	r25, 7
 8dc:	07 2e       	mov	r0, r23
 8de:	16 f4       	brtc	.+4      	; 0x8e4 <__divmodhi4+0xa>
 8e0:	00 94       	com	r0
 8e2:	07 d0       	rcall	.+14     	; 0x8f2 <__divmodhi4_neg1>
 8e4:	77 fd       	sbrc	r23, 7
 8e6:	09 d0       	rcall	.+18     	; 0x8fa <__divmodhi4_neg2>
 8e8:	0e 94 81 04 	call	0x902	; 0x902 <__udivmodhi4>
 8ec:	07 fc       	sbrc	r0, 7
 8ee:	05 d0       	rcall	.+10     	; 0x8fa <__divmodhi4_neg2>
 8f0:	3e f4       	brtc	.+14     	; 0x900 <__divmodhi4_exit>

000008f2 <__divmodhi4_neg1>:
 8f2:	90 95       	com	r25
 8f4:	81 95       	neg	r24
 8f6:	9f 4f       	sbci	r25, 0xFF	; 255
 8f8:	08 95       	ret

000008fa <__divmodhi4_neg2>:
 8fa:	70 95       	com	r23
 8fc:	61 95       	neg	r22
 8fe:	7f 4f       	sbci	r23, 0xFF	; 255

00000900 <__divmodhi4_exit>:
 900:	08 95       	ret

00000902 <__udivmodhi4>:
 902:	aa 1b       	sub	r26, r26
 904:	bb 1b       	sub	r27, r27
 906:	51 e1       	ldi	r21, 0x11	; 17
 908:	07 c0       	rjmp	.+14     	; 0x918 <__udivmodhi4_ep>

0000090a <__udivmodhi4_loop>:
 90a:	aa 1f       	adc	r26, r26
 90c:	bb 1f       	adc	r27, r27
 90e:	a6 17       	cp	r26, r22
 910:	b7 07       	cpc	r27, r23
 912:	10 f0       	brcs	.+4      	; 0x918 <__udivmodhi4_ep>
 914:	a6 1b       	sub	r26, r22
 916:	b7 0b       	sbc	r27, r23

00000918 <__udivmodhi4_ep>:
 918:	88 1f       	adc	r24, r24
 91a:	99 1f       	adc	r25, r25
 91c:	5a 95       	dec	r21
 91e:	a9 f7       	brne	.-22     	; 0x90a <__udivmodhi4_loop>
 920:	80 95       	com	r24
 922:	90 95       	com	r25
 924:	bc 01       	movw	r22, r24
 926:	cd 01       	movw	r24, r26
 928:	08 95       	ret

0000092a <sprintf>:
 92a:	ae e0       	ldi	r26, 0x0E	; 14
 92c:	b0 e0       	ldi	r27, 0x00	; 0
 92e:	eb e9       	ldi	r30, 0x9B	; 155
 930:	f4 e0       	ldi	r31, 0x04	; 4
 932:	0c 94 56 07 	jmp	0xeac	; 0xeac <__prologue_saves__+0x1c>
 936:	0d 89       	ldd	r16, Y+21	; 0x15
 938:	1e 89       	ldd	r17, Y+22	; 0x16
 93a:	86 e0       	ldi	r24, 0x06	; 6
 93c:	8c 83       	std	Y+4, r24	; 0x04
 93e:	1a 83       	std	Y+2, r17	; 0x02
 940:	09 83       	std	Y+1, r16	; 0x01
 942:	8f ef       	ldi	r24, 0xFF	; 255
 944:	9f e7       	ldi	r25, 0x7F	; 127
 946:	9e 83       	std	Y+6, r25	; 0x06
 948:	8d 83       	std	Y+5, r24	; 0x05
 94a:	ae 01       	movw	r20, r28
 94c:	47 5e       	subi	r20, 0xE7	; 231
 94e:	5f 4f       	sbci	r21, 0xFF	; 255
 950:	6f 89       	ldd	r22, Y+23	; 0x17
 952:	78 8d       	ldd	r23, Y+24	; 0x18
 954:	ce 01       	movw	r24, r28
 956:	01 96       	adiw	r24, 0x01	; 1
 958:	0e 94 b7 04 	call	0x96e	; 0x96e <vfprintf>
 95c:	ef 81       	ldd	r30, Y+7	; 0x07
 95e:	f8 85       	ldd	r31, Y+8	; 0x08
 960:	e0 0f       	add	r30, r16
 962:	f1 1f       	adc	r31, r17
 964:	10 82       	st	Z, r1
 966:	2e 96       	adiw	r28, 0x0e	; 14
 968:	e4 e0       	ldi	r30, 0x04	; 4
 96a:	0c 94 72 07 	jmp	0xee4	; 0xee4 <__epilogue_restores__+0x1c>

0000096e <vfprintf>:
 96e:	ab e0       	ldi	r26, 0x0B	; 11
 970:	b0 e0       	ldi	r27, 0x00	; 0
 972:	ed eb       	ldi	r30, 0xBD	; 189
 974:	f4 e0       	ldi	r31, 0x04	; 4
 976:	0c 94 48 07 	jmp	0xe90	; 0xe90 <__prologue_saves__>
 97a:	6c 01       	movw	r12, r24
 97c:	7b 01       	movw	r14, r22
 97e:	8a 01       	movw	r16, r20
 980:	fc 01       	movw	r30, r24
 982:	17 82       	std	Z+7, r1	; 0x07
 984:	16 82       	std	Z+6, r1	; 0x06
 986:	83 81       	ldd	r24, Z+3	; 0x03
 988:	81 ff       	sbrs	r24, 1
 98a:	cc c1       	rjmp	.+920    	; 0xd24 <vfprintf+0x3b6>
 98c:	ce 01       	movw	r24, r28
 98e:	01 96       	adiw	r24, 0x01	; 1
 990:	3c 01       	movw	r6, r24
 992:	f6 01       	movw	r30, r12
 994:	93 81       	ldd	r25, Z+3	; 0x03
 996:	f7 01       	movw	r30, r14
 998:	93 fd       	sbrc	r25, 3
 99a:	85 91       	lpm	r24, Z+
 99c:	93 ff       	sbrs	r25, 3
 99e:	81 91       	ld	r24, Z+
 9a0:	7f 01       	movw	r14, r30
 9a2:	88 23       	and	r24, r24
 9a4:	09 f4       	brne	.+2      	; 0x9a8 <vfprintf+0x3a>
 9a6:	ba c1       	rjmp	.+884    	; 0xd1c <vfprintf+0x3ae>
 9a8:	85 32       	cpi	r24, 0x25	; 37
 9aa:	39 f4       	brne	.+14     	; 0x9ba <vfprintf+0x4c>
 9ac:	93 fd       	sbrc	r25, 3
 9ae:	85 91       	lpm	r24, Z+
 9b0:	93 ff       	sbrs	r25, 3
 9b2:	81 91       	ld	r24, Z+
 9b4:	7f 01       	movw	r14, r30
 9b6:	85 32       	cpi	r24, 0x25	; 37
 9b8:	29 f4       	brne	.+10     	; 0x9c4 <vfprintf+0x56>
 9ba:	b6 01       	movw	r22, r12
 9bc:	90 e0       	ldi	r25, 0x00	; 0
 9be:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 9c2:	e7 cf       	rjmp	.-50     	; 0x992 <vfprintf+0x24>
 9c4:	91 2c       	mov	r9, r1
 9c6:	21 2c       	mov	r2, r1
 9c8:	31 2c       	mov	r3, r1
 9ca:	ff e1       	ldi	r31, 0x1F	; 31
 9cc:	f3 15       	cp	r31, r3
 9ce:	d8 f0       	brcs	.+54     	; 0xa06 <vfprintf+0x98>
 9d0:	8b 32       	cpi	r24, 0x2B	; 43
 9d2:	79 f0       	breq	.+30     	; 0x9f2 <vfprintf+0x84>
 9d4:	38 f4       	brcc	.+14     	; 0x9e4 <vfprintf+0x76>
 9d6:	80 32       	cpi	r24, 0x20	; 32
 9d8:	79 f0       	breq	.+30     	; 0x9f8 <vfprintf+0x8a>
 9da:	83 32       	cpi	r24, 0x23	; 35
 9dc:	a1 f4       	brne	.+40     	; 0xa06 <vfprintf+0x98>
 9de:	23 2d       	mov	r18, r3
 9e0:	20 61       	ori	r18, 0x10	; 16
 9e2:	1d c0       	rjmp	.+58     	; 0xa1e <vfprintf+0xb0>
 9e4:	8d 32       	cpi	r24, 0x2D	; 45
 9e6:	61 f0       	breq	.+24     	; 0xa00 <vfprintf+0x92>
 9e8:	80 33       	cpi	r24, 0x30	; 48
 9ea:	69 f4       	brne	.+26     	; 0xa06 <vfprintf+0x98>
 9ec:	23 2d       	mov	r18, r3
 9ee:	21 60       	ori	r18, 0x01	; 1
 9f0:	16 c0       	rjmp	.+44     	; 0xa1e <vfprintf+0xb0>
 9f2:	83 2d       	mov	r24, r3
 9f4:	82 60       	ori	r24, 0x02	; 2
 9f6:	38 2e       	mov	r3, r24
 9f8:	e3 2d       	mov	r30, r3
 9fa:	e4 60       	ori	r30, 0x04	; 4
 9fc:	3e 2e       	mov	r3, r30
 9fe:	2a c0       	rjmp	.+84     	; 0xa54 <vfprintf+0xe6>
 a00:	f3 2d       	mov	r31, r3
 a02:	f8 60       	ori	r31, 0x08	; 8
 a04:	1d c0       	rjmp	.+58     	; 0xa40 <vfprintf+0xd2>
 a06:	37 fc       	sbrc	r3, 7
 a08:	2d c0       	rjmp	.+90     	; 0xa64 <vfprintf+0xf6>
 a0a:	20 ed       	ldi	r18, 0xD0	; 208
 a0c:	28 0f       	add	r18, r24
 a0e:	2a 30       	cpi	r18, 0x0A	; 10
 a10:	40 f0       	brcs	.+16     	; 0xa22 <vfprintf+0xb4>
 a12:	8e 32       	cpi	r24, 0x2E	; 46
 a14:	b9 f4       	brne	.+46     	; 0xa44 <vfprintf+0xd6>
 a16:	36 fc       	sbrc	r3, 6
 a18:	81 c1       	rjmp	.+770    	; 0xd1c <vfprintf+0x3ae>
 a1a:	23 2d       	mov	r18, r3
 a1c:	20 64       	ori	r18, 0x40	; 64
 a1e:	32 2e       	mov	r3, r18
 a20:	19 c0       	rjmp	.+50     	; 0xa54 <vfprintf+0xe6>
 a22:	36 fe       	sbrs	r3, 6
 a24:	06 c0       	rjmp	.+12     	; 0xa32 <vfprintf+0xc4>
 a26:	8a e0       	ldi	r24, 0x0A	; 10
 a28:	98 9e       	mul	r9, r24
 a2a:	20 0d       	add	r18, r0
 a2c:	11 24       	eor	r1, r1
 a2e:	92 2e       	mov	r9, r18
 a30:	11 c0       	rjmp	.+34     	; 0xa54 <vfprintf+0xe6>
 a32:	ea e0       	ldi	r30, 0x0A	; 10
 a34:	2e 9e       	mul	r2, r30
 a36:	20 0d       	add	r18, r0
 a38:	11 24       	eor	r1, r1
 a3a:	22 2e       	mov	r2, r18
 a3c:	f3 2d       	mov	r31, r3
 a3e:	f0 62       	ori	r31, 0x20	; 32
 a40:	3f 2e       	mov	r3, r31
 a42:	08 c0       	rjmp	.+16     	; 0xa54 <vfprintf+0xe6>
 a44:	8c 36       	cpi	r24, 0x6C	; 108
 a46:	21 f4       	brne	.+8      	; 0xa50 <vfprintf+0xe2>
 a48:	83 2d       	mov	r24, r3
 a4a:	80 68       	ori	r24, 0x80	; 128
 a4c:	38 2e       	mov	r3, r24
 a4e:	02 c0       	rjmp	.+4      	; 0xa54 <vfprintf+0xe6>
 a50:	88 36       	cpi	r24, 0x68	; 104
 a52:	41 f4       	brne	.+16     	; 0xa64 <vfprintf+0xf6>
 a54:	f7 01       	movw	r30, r14
 a56:	93 fd       	sbrc	r25, 3
 a58:	85 91       	lpm	r24, Z+
 a5a:	93 ff       	sbrs	r25, 3
 a5c:	81 91       	ld	r24, Z+
 a5e:	7f 01       	movw	r14, r30
 a60:	81 11       	cpse	r24, r1
 a62:	b3 cf       	rjmp	.-154    	; 0x9ca <vfprintf+0x5c>
 a64:	98 2f       	mov	r25, r24
 a66:	9f 7d       	andi	r25, 0xDF	; 223
 a68:	95 54       	subi	r25, 0x45	; 69
 a6a:	93 30       	cpi	r25, 0x03	; 3
 a6c:	28 f4       	brcc	.+10     	; 0xa78 <vfprintf+0x10a>
 a6e:	0c 5f       	subi	r16, 0xFC	; 252
 a70:	1f 4f       	sbci	r17, 0xFF	; 255
 a72:	9f e3       	ldi	r25, 0x3F	; 63
 a74:	99 83       	std	Y+1, r25	; 0x01
 a76:	0d c0       	rjmp	.+26     	; 0xa92 <vfprintf+0x124>
 a78:	83 36       	cpi	r24, 0x63	; 99
 a7a:	31 f0       	breq	.+12     	; 0xa88 <vfprintf+0x11a>
 a7c:	83 37       	cpi	r24, 0x73	; 115
 a7e:	71 f0       	breq	.+28     	; 0xa9c <vfprintf+0x12e>
 a80:	83 35       	cpi	r24, 0x53	; 83
 a82:	09 f0       	breq	.+2      	; 0xa86 <vfprintf+0x118>
 a84:	59 c0       	rjmp	.+178    	; 0xb38 <vfprintf+0x1ca>
 a86:	21 c0       	rjmp	.+66     	; 0xaca <vfprintf+0x15c>
 a88:	f8 01       	movw	r30, r16
 a8a:	80 81       	ld	r24, Z
 a8c:	89 83       	std	Y+1, r24	; 0x01
 a8e:	0e 5f       	subi	r16, 0xFE	; 254
 a90:	1f 4f       	sbci	r17, 0xFF	; 255
 a92:	88 24       	eor	r8, r8
 a94:	83 94       	inc	r8
 a96:	91 2c       	mov	r9, r1
 a98:	53 01       	movw	r10, r6
 a9a:	13 c0       	rjmp	.+38     	; 0xac2 <vfprintf+0x154>
 a9c:	28 01       	movw	r4, r16
 a9e:	f2 e0       	ldi	r31, 0x02	; 2
 aa0:	4f 0e       	add	r4, r31
 aa2:	51 1c       	adc	r5, r1
 aa4:	f8 01       	movw	r30, r16
 aa6:	a0 80       	ld	r10, Z
 aa8:	b1 80       	ldd	r11, Z+1	; 0x01
 aaa:	36 fe       	sbrs	r3, 6
 aac:	03 c0       	rjmp	.+6      	; 0xab4 <vfprintf+0x146>
 aae:	69 2d       	mov	r22, r9
 ab0:	70 e0       	ldi	r23, 0x00	; 0
 ab2:	02 c0       	rjmp	.+4      	; 0xab8 <vfprintf+0x14a>
 ab4:	6f ef       	ldi	r22, 0xFF	; 255
 ab6:	7f ef       	ldi	r23, 0xFF	; 255
 ab8:	c5 01       	movw	r24, r10
 aba:	0e 94 a3 06 	call	0xd46	; 0xd46 <strnlen>
 abe:	4c 01       	movw	r8, r24
 ac0:	82 01       	movw	r16, r4
 ac2:	f3 2d       	mov	r31, r3
 ac4:	ff 77       	andi	r31, 0x7F	; 127
 ac6:	3f 2e       	mov	r3, r31
 ac8:	16 c0       	rjmp	.+44     	; 0xaf6 <vfprintf+0x188>
 aca:	28 01       	movw	r4, r16
 acc:	22 e0       	ldi	r18, 0x02	; 2
 ace:	42 0e       	add	r4, r18
 ad0:	51 1c       	adc	r5, r1
 ad2:	f8 01       	movw	r30, r16
 ad4:	a0 80       	ld	r10, Z
 ad6:	b1 80       	ldd	r11, Z+1	; 0x01
 ad8:	36 fe       	sbrs	r3, 6
 ada:	03 c0       	rjmp	.+6      	; 0xae2 <vfprintf+0x174>
 adc:	69 2d       	mov	r22, r9
 ade:	70 e0       	ldi	r23, 0x00	; 0
 ae0:	02 c0       	rjmp	.+4      	; 0xae6 <vfprintf+0x178>
 ae2:	6f ef       	ldi	r22, 0xFF	; 255
 ae4:	7f ef       	ldi	r23, 0xFF	; 255
 ae6:	c5 01       	movw	r24, r10
 ae8:	0e 94 98 06 	call	0xd30	; 0xd30 <strnlen_P>
 aec:	4c 01       	movw	r8, r24
 aee:	f3 2d       	mov	r31, r3
 af0:	f0 68       	ori	r31, 0x80	; 128
 af2:	3f 2e       	mov	r3, r31
 af4:	82 01       	movw	r16, r4
 af6:	33 fc       	sbrc	r3, 3
 af8:	1b c0       	rjmp	.+54     	; 0xb30 <vfprintf+0x1c2>
 afa:	82 2d       	mov	r24, r2
 afc:	90 e0       	ldi	r25, 0x00	; 0
 afe:	88 16       	cp	r8, r24
 b00:	99 06       	cpc	r9, r25
 b02:	b0 f4       	brcc	.+44     	; 0xb30 <vfprintf+0x1c2>
 b04:	b6 01       	movw	r22, r12
 b06:	80 e2       	ldi	r24, 0x20	; 32
 b08:	90 e0       	ldi	r25, 0x00	; 0
 b0a:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 b0e:	2a 94       	dec	r2
 b10:	f4 cf       	rjmp	.-24     	; 0xafa <vfprintf+0x18c>
 b12:	f5 01       	movw	r30, r10
 b14:	37 fc       	sbrc	r3, 7
 b16:	85 91       	lpm	r24, Z+
 b18:	37 fe       	sbrs	r3, 7
 b1a:	81 91       	ld	r24, Z+
 b1c:	5f 01       	movw	r10, r30
 b1e:	b6 01       	movw	r22, r12
 b20:	90 e0       	ldi	r25, 0x00	; 0
 b22:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 b26:	21 10       	cpse	r2, r1
 b28:	2a 94       	dec	r2
 b2a:	21 e0       	ldi	r18, 0x01	; 1
 b2c:	82 1a       	sub	r8, r18
 b2e:	91 08       	sbc	r9, r1
 b30:	81 14       	cp	r8, r1
 b32:	91 04       	cpc	r9, r1
 b34:	71 f7       	brne	.-36     	; 0xb12 <vfprintf+0x1a4>
 b36:	e8 c0       	rjmp	.+464    	; 0xd08 <vfprintf+0x39a>
 b38:	84 36       	cpi	r24, 0x64	; 100
 b3a:	11 f0       	breq	.+4      	; 0xb40 <vfprintf+0x1d2>
 b3c:	89 36       	cpi	r24, 0x69	; 105
 b3e:	41 f5       	brne	.+80     	; 0xb90 <vfprintf+0x222>
 b40:	f8 01       	movw	r30, r16
 b42:	37 fe       	sbrs	r3, 7
 b44:	07 c0       	rjmp	.+14     	; 0xb54 <vfprintf+0x1e6>
 b46:	60 81       	ld	r22, Z
 b48:	71 81       	ldd	r23, Z+1	; 0x01
 b4a:	82 81       	ldd	r24, Z+2	; 0x02
 b4c:	93 81       	ldd	r25, Z+3	; 0x03
 b4e:	0c 5f       	subi	r16, 0xFC	; 252
 b50:	1f 4f       	sbci	r17, 0xFF	; 255
 b52:	08 c0       	rjmp	.+16     	; 0xb64 <vfprintf+0x1f6>
 b54:	60 81       	ld	r22, Z
 b56:	71 81       	ldd	r23, Z+1	; 0x01
 b58:	07 2e       	mov	r0, r23
 b5a:	00 0c       	add	r0, r0
 b5c:	88 0b       	sbc	r24, r24
 b5e:	99 0b       	sbc	r25, r25
 b60:	0e 5f       	subi	r16, 0xFE	; 254
 b62:	1f 4f       	sbci	r17, 0xFF	; 255
 b64:	f3 2d       	mov	r31, r3
 b66:	ff 76       	andi	r31, 0x6F	; 111
 b68:	3f 2e       	mov	r3, r31
 b6a:	97 ff       	sbrs	r25, 7
 b6c:	09 c0       	rjmp	.+18     	; 0xb80 <vfprintf+0x212>
 b6e:	90 95       	com	r25
 b70:	80 95       	com	r24
 b72:	70 95       	com	r23
 b74:	61 95       	neg	r22
 b76:	7f 4f       	sbci	r23, 0xFF	; 255
 b78:	8f 4f       	sbci	r24, 0xFF	; 255
 b7a:	9f 4f       	sbci	r25, 0xFF	; 255
 b7c:	f0 68       	ori	r31, 0x80	; 128
 b7e:	3f 2e       	mov	r3, r31
 b80:	2a e0       	ldi	r18, 0x0A	; 10
 b82:	30 e0       	ldi	r19, 0x00	; 0
 b84:	a3 01       	movw	r20, r6
 b86:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <__ultoa_invert>
 b8a:	88 2e       	mov	r8, r24
 b8c:	86 18       	sub	r8, r6
 b8e:	45 c0       	rjmp	.+138    	; 0xc1a <vfprintf+0x2ac>
 b90:	85 37       	cpi	r24, 0x75	; 117
 b92:	31 f4       	brne	.+12     	; 0xba0 <vfprintf+0x232>
 b94:	23 2d       	mov	r18, r3
 b96:	2f 7e       	andi	r18, 0xEF	; 239
 b98:	b2 2e       	mov	r11, r18
 b9a:	2a e0       	ldi	r18, 0x0A	; 10
 b9c:	30 e0       	ldi	r19, 0x00	; 0
 b9e:	25 c0       	rjmp	.+74     	; 0xbea <vfprintf+0x27c>
 ba0:	93 2d       	mov	r25, r3
 ba2:	99 7f       	andi	r25, 0xF9	; 249
 ba4:	b9 2e       	mov	r11, r25
 ba6:	8f 36       	cpi	r24, 0x6F	; 111
 ba8:	c1 f0       	breq	.+48     	; 0xbda <vfprintf+0x26c>
 baa:	18 f4       	brcc	.+6      	; 0xbb2 <vfprintf+0x244>
 bac:	88 35       	cpi	r24, 0x58	; 88
 bae:	79 f0       	breq	.+30     	; 0xbce <vfprintf+0x260>
 bb0:	b5 c0       	rjmp	.+362    	; 0xd1c <vfprintf+0x3ae>
 bb2:	80 37       	cpi	r24, 0x70	; 112
 bb4:	19 f0       	breq	.+6      	; 0xbbc <vfprintf+0x24e>
 bb6:	88 37       	cpi	r24, 0x78	; 120
 bb8:	21 f0       	breq	.+8      	; 0xbc2 <vfprintf+0x254>
 bba:	b0 c0       	rjmp	.+352    	; 0xd1c <vfprintf+0x3ae>
 bbc:	e9 2f       	mov	r30, r25
 bbe:	e0 61       	ori	r30, 0x10	; 16
 bc0:	be 2e       	mov	r11, r30
 bc2:	b4 fe       	sbrs	r11, 4
 bc4:	0d c0       	rjmp	.+26     	; 0xbe0 <vfprintf+0x272>
 bc6:	fb 2d       	mov	r31, r11
 bc8:	f4 60       	ori	r31, 0x04	; 4
 bca:	bf 2e       	mov	r11, r31
 bcc:	09 c0       	rjmp	.+18     	; 0xbe0 <vfprintf+0x272>
 bce:	34 fe       	sbrs	r3, 4
 bd0:	0a c0       	rjmp	.+20     	; 0xbe6 <vfprintf+0x278>
 bd2:	29 2f       	mov	r18, r25
 bd4:	26 60       	ori	r18, 0x06	; 6
 bd6:	b2 2e       	mov	r11, r18
 bd8:	06 c0       	rjmp	.+12     	; 0xbe6 <vfprintf+0x278>
 bda:	28 e0       	ldi	r18, 0x08	; 8
 bdc:	30 e0       	ldi	r19, 0x00	; 0
 bde:	05 c0       	rjmp	.+10     	; 0xbea <vfprintf+0x27c>
 be0:	20 e1       	ldi	r18, 0x10	; 16
 be2:	30 e0       	ldi	r19, 0x00	; 0
 be4:	02 c0       	rjmp	.+4      	; 0xbea <vfprintf+0x27c>
 be6:	20 e1       	ldi	r18, 0x10	; 16
 be8:	32 e0       	ldi	r19, 0x02	; 2
 bea:	f8 01       	movw	r30, r16
 bec:	b7 fe       	sbrs	r11, 7
 bee:	07 c0       	rjmp	.+14     	; 0xbfe <vfprintf+0x290>
 bf0:	60 81       	ld	r22, Z
 bf2:	71 81       	ldd	r23, Z+1	; 0x01
 bf4:	82 81       	ldd	r24, Z+2	; 0x02
 bf6:	93 81       	ldd	r25, Z+3	; 0x03
 bf8:	0c 5f       	subi	r16, 0xFC	; 252
 bfa:	1f 4f       	sbci	r17, 0xFF	; 255
 bfc:	06 c0       	rjmp	.+12     	; 0xc0a <vfprintf+0x29c>
 bfe:	60 81       	ld	r22, Z
 c00:	71 81       	ldd	r23, Z+1	; 0x01
 c02:	80 e0       	ldi	r24, 0x00	; 0
 c04:	90 e0       	ldi	r25, 0x00	; 0
 c06:	0e 5f       	subi	r16, 0xFE	; 254
 c08:	1f 4f       	sbci	r17, 0xFF	; 255
 c0a:	a3 01       	movw	r20, r6
 c0c:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <__ultoa_invert>
 c10:	88 2e       	mov	r8, r24
 c12:	86 18       	sub	r8, r6
 c14:	fb 2d       	mov	r31, r11
 c16:	ff 77       	andi	r31, 0x7F	; 127
 c18:	3f 2e       	mov	r3, r31
 c1a:	36 fe       	sbrs	r3, 6
 c1c:	0d c0       	rjmp	.+26     	; 0xc38 <vfprintf+0x2ca>
 c1e:	23 2d       	mov	r18, r3
 c20:	2e 7f       	andi	r18, 0xFE	; 254
 c22:	a2 2e       	mov	r10, r18
 c24:	89 14       	cp	r8, r9
 c26:	58 f4       	brcc	.+22     	; 0xc3e <vfprintf+0x2d0>
 c28:	34 fe       	sbrs	r3, 4
 c2a:	0b c0       	rjmp	.+22     	; 0xc42 <vfprintf+0x2d4>
 c2c:	32 fc       	sbrc	r3, 2
 c2e:	09 c0       	rjmp	.+18     	; 0xc42 <vfprintf+0x2d4>
 c30:	83 2d       	mov	r24, r3
 c32:	8e 7e       	andi	r24, 0xEE	; 238
 c34:	a8 2e       	mov	r10, r24
 c36:	05 c0       	rjmp	.+10     	; 0xc42 <vfprintf+0x2d4>
 c38:	b8 2c       	mov	r11, r8
 c3a:	a3 2c       	mov	r10, r3
 c3c:	03 c0       	rjmp	.+6      	; 0xc44 <vfprintf+0x2d6>
 c3e:	b8 2c       	mov	r11, r8
 c40:	01 c0       	rjmp	.+2      	; 0xc44 <vfprintf+0x2d6>
 c42:	b9 2c       	mov	r11, r9
 c44:	a4 fe       	sbrs	r10, 4
 c46:	0f c0       	rjmp	.+30     	; 0xc66 <vfprintf+0x2f8>
 c48:	fe 01       	movw	r30, r28
 c4a:	e8 0d       	add	r30, r8
 c4c:	f1 1d       	adc	r31, r1
 c4e:	80 81       	ld	r24, Z
 c50:	80 33       	cpi	r24, 0x30	; 48
 c52:	21 f4       	brne	.+8      	; 0xc5c <vfprintf+0x2ee>
 c54:	9a 2d       	mov	r25, r10
 c56:	99 7e       	andi	r25, 0xE9	; 233
 c58:	a9 2e       	mov	r10, r25
 c5a:	09 c0       	rjmp	.+18     	; 0xc6e <vfprintf+0x300>
 c5c:	a2 fe       	sbrs	r10, 2
 c5e:	06 c0       	rjmp	.+12     	; 0xc6c <vfprintf+0x2fe>
 c60:	b3 94       	inc	r11
 c62:	b3 94       	inc	r11
 c64:	04 c0       	rjmp	.+8      	; 0xc6e <vfprintf+0x300>
 c66:	8a 2d       	mov	r24, r10
 c68:	86 78       	andi	r24, 0x86	; 134
 c6a:	09 f0       	breq	.+2      	; 0xc6e <vfprintf+0x300>
 c6c:	b3 94       	inc	r11
 c6e:	a3 fc       	sbrc	r10, 3
 c70:	11 c0       	rjmp	.+34     	; 0xc94 <vfprintf+0x326>
 c72:	a0 fe       	sbrs	r10, 0
 c74:	06 c0       	rjmp	.+12     	; 0xc82 <vfprintf+0x314>
 c76:	b2 14       	cp	r11, r2
 c78:	88 f4       	brcc	.+34     	; 0xc9c <vfprintf+0x32e>
 c7a:	28 0c       	add	r2, r8
 c7c:	92 2c       	mov	r9, r2
 c7e:	9b 18       	sub	r9, r11
 c80:	0e c0       	rjmp	.+28     	; 0xc9e <vfprintf+0x330>
 c82:	b2 14       	cp	r11, r2
 c84:	60 f4       	brcc	.+24     	; 0xc9e <vfprintf+0x330>
 c86:	b6 01       	movw	r22, r12
 c88:	80 e2       	ldi	r24, 0x20	; 32
 c8a:	90 e0       	ldi	r25, 0x00	; 0
 c8c:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 c90:	b3 94       	inc	r11
 c92:	f7 cf       	rjmp	.-18     	; 0xc82 <vfprintf+0x314>
 c94:	b2 14       	cp	r11, r2
 c96:	18 f4       	brcc	.+6      	; 0xc9e <vfprintf+0x330>
 c98:	2b 18       	sub	r2, r11
 c9a:	02 c0       	rjmp	.+4      	; 0xca0 <vfprintf+0x332>
 c9c:	98 2c       	mov	r9, r8
 c9e:	21 2c       	mov	r2, r1
 ca0:	a4 fe       	sbrs	r10, 4
 ca2:	10 c0       	rjmp	.+32     	; 0xcc4 <vfprintf+0x356>
 ca4:	b6 01       	movw	r22, r12
 ca6:	80 e3       	ldi	r24, 0x30	; 48
 ca8:	90 e0       	ldi	r25, 0x00	; 0
 caa:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 cae:	a2 fe       	sbrs	r10, 2
 cb0:	17 c0       	rjmp	.+46     	; 0xce0 <vfprintf+0x372>
 cb2:	a1 fc       	sbrc	r10, 1
 cb4:	03 c0       	rjmp	.+6      	; 0xcbc <vfprintf+0x34e>
 cb6:	88 e7       	ldi	r24, 0x78	; 120
 cb8:	90 e0       	ldi	r25, 0x00	; 0
 cba:	02 c0       	rjmp	.+4      	; 0xcc0 <vfprintf+0x352>
 cbc:	88 e5       	ldi	r24, 0x58	; 88
 cbe:	90 e0       	ldi	r25, 0x00	; 0
 cc0:	b6 01       	movw	r22, r12
 cc2:	0c c0       	rjmp	.+24     	; 0xcdc <vfprintf+0x36e>
 cc4:	8a 2d       	mov	r24, r10
 cc6:	86 78       	andi	r24, 0x86	; 134
 cc8:	59 f0       	breq	.+22     	; 0xce0 <vfprintf+0x372>
 cca:	a1 fe       	sbrs	r10, 1
 ccc:	02 c0       	rjmp	.+4      	; 0xcd2 <vfprintf+0x364>
 cce:	8b e2       	ldi	r24, 0x2B	; 43
 cd0:	01 c0       	rjmp	.+2      	; 0xcd4 <vfprintf+0x366>
 cd2:	80 e2       	ldi	r24, 0x20	; 32
 cd4:	a7 fc       	sbrc	r10, 7
 cd6:	8d e2       	ldi	r24, 0x2D	; 45
 cd8:	b6 01       	movw	r22, r12
 cda:	90 e0       	ldi	r25, 0x00	; 0
 cdc:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 ce0:	89 14       	cp	r8, r9
 ce2:	38 f4       	brcc	.+14     	; 0xcf2 <vfprintf+0x384>
 ce4:	b6 01       	movw	r22, r12
 ce6:	80 e3       	ldi	r24, 0x30	; 48
 ce8:	90 e0       	ldi	r25, 0x00	; 0
 cea:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 cee:	9a 94       	dec	r9
 cf0:	f7 cf       	rjmp	.-18     	; 0xce0 <vfprintf+0x372>
 cf2:	8a 94       	dec	r8
 cf4:	f3 01       	movw	r30, r6
 cf6:	e8 0d       	add	r30, r8
 cf8:	f1 1d       	adc	r31, r1
 cfa:	80 81       	ld	r24, Z
 cfc:	b6 01       	movw	r22, r12
 cfe:	90 e0       	ldi	r25, 0x00	; 0
 d00:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 d04:	81 10       	cpse	r8, r1
 d06:	f5 cf       	rjmp	.-22     	; 0xcf2 <vfprintf+0x384>
 d08:	22 20       	and	r2, r2
 d0a:	09 f4       	brne	.+2      	; 0xd0e <vfprintf+0x3a0>
 d0c:	42 ce       	rjmp	.-892    	; 0x992 <vfprintf+0x24>
 d0e:	b6 01       	movw	r22, r12
 d10:	80 e2       	ldi	r24, 0x20	; 32
 d12:	90 e0       	ldi	r25, 0x00	; 0
 d14:	0e 94 ae 06 	call	0xd5c	; 0xd5c <fputc>
 d18:	2a 94       	dec	r2
 d1a:	f6 cf       	rjmp	.-20     	; 0xd08 <vfprintf+0x39a>
 d1c:	f6 01       	movw	r30, r12
 d1e:	86 81       	ldd	r24, Z+6	; 0x06
 d20:	97 81       	ldd	r25, Z+7	; 0x07
 d22:	02 c0       	rjmp	.+4      	; 0xd28 <vfprintf+0x3ba>
 d24:	8f ef       	ldi	r24, 0xFF	; 255
 d26:	9f ef       	ldi	r25, 0xFF	; 255
 d28:	2b 96       	adiw	r28, 0x0b	; 11
 d2a:	e2 e1       	ldi	r30, 0x12	; 18
 d2c:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__epilogue_restores__>

00000d30 <strnlen_P>:
 d30:	fc 01       	movw	r30, r24
 d32:	05 90       	lpm	r0, Z+
 d34:	61 50       	subi	r22, 0x01	; 1
 d36:	70 40       	sbci	r23, 0x00	; 0
 d38:	01 10       	cpse	r0, r1
 d3a:	d8 f7       	brcc	.-10     	; 0xd32 <strnlen_P+0x2>
 d3c:	80 95       	com	r24
 d3e:	90 95       	com	r25
 d40:	8e 0f       	add	r24, r30
 d42:	9f 1f       	adc	r25, r31
 d44:	08 95       	ret

00000d46 <strnlen>:
 d46:	fc 01       	movw	r30, r24
 d48:	61 50       	subi	r22, 0x01	; 1
 d4a:	70 40       	sbci	r23, 0x00	; 0
 d4c:	01 90       	ld	r0, Z+
 d4e:	01 10       	cpse	r0, r1
 d50:	d8 f7       	brcc	.-10     	; 0xd48 <strnlen+0x2>
 d52:	80 95       	com	r24
 d54:	90 95       	com	r25
 d56:	8e 0f       	add	r24, r30
 d58:	9f 1f       	adc	r25, r31
 d5a:	08 95       	ret

00000d5c <fputc>:
 d5c:	0f 93       	push	r16
 d5e:	1f 93       	push	r17
 d60:	cf 93       	push	r28
 d62:	df 93       	push	r29
 d64:	fb 01       	movw	r30, r22
 d66:	23 81       	ldd	r18, Z+3	; 0x03
 d68:	21 fd       	sbrc	r18, 1
 d6a:	03 c0       	rjmp	.+6      	; 0xd72 <fputc+0x16>
 d6c:	8f ef       	ldi	r24, 0xFF	; 255
 d6e:	9f ef       	ldi	r25, 0xFF	; 255
 d70:	2c c0       	rjmp	.+88     	; 0xdca <fputc+0x6e>
 d72:	22 ff       	sbrs	r18, 2
 d74:	16 c0       	rjmp	.+44     	; 0xda2 <fputc+0x46>
 d76:	46 81       	ldd	r20, Z+6	; 0x06
 d78:	57 81       	ldd	r21, Z+7	; 0x07
 d7a:	24 81       	ldd	r18, Z+4	; 0x04
 d7c:	35 81       	ldd	r19, Z+5	; 0x05
 d7e:	42 17       	cp	r20, r18
 d80:	53 07       	cpc	r21, r19
 d82:	44 f4       	brge	.+16     	; 0xd94 <fputc+0x38>
 d84:	a0 81       	ld	r26, Z
 d86:	b1 81       	ldd	r27, Z+1	; 0x01
 d88:	9d 01       	movw	r18, r26
 d8a:	2f 5f       	subi	r18, 0xFF	; 255
 d8c:	3f 4f       	sbci	r19, 0xFF	; 255
 d8e:	31 83       	std	Z+1, r19	; 0x01
 d90:	20 83       	st	Z, r18
 d92:	8c 93       	st	X, r24
 d94:	26 81       	ldd	r18, Z+6	; 0x06
 d96:	37 81       	ldd	r19, Z+7	; 0x07
 d98:	2f 5f       	subi	r18, 0xFF	; 255
 d9a:	3f 4f       	sbci	r19, 0xFF	; 255
 d9c:	37 83       	std	Z+7, r19	; 0x07
 d9e:	26 83       	std	Z+6, r18	; 0x06
 da0:	14 c0       	rjmp	.+40     	; 0xdca <fputc+0x6e>
 da2:	8b 01       	movw	r16, r22
 da4:	ec 01       	movw	r28, r24
 da6:	fb 01       	movw	r30, r22
 da8:	00 84       	ldd	r0, Z+8	; 0x08
 daa:	f1 85       	ldd	r31, Z+9	; 0x09
 dac:	e0 2d       	mov	r30, r0
 dae:	09 95       	icall
 db0:	89 2b       	or	r24, r25
 db2:	e1 f6       	brne	.-72     	; 0xd6c <fputc+0x10>
 db4:	d8 01       	movw	r26, r16
 db6:	16 96       	adiw	r26, 0x06	; 6
 db8:	8d 91       	ld	r24, X+
 dba:	9c 91       	ld	r25, X
 dbc:	17 97       	sbiw	r26, 0x07	; 7
 dbe:	01 96       	adiw	r24, 0x01	; 1
 dc0:	17 96       	adiw	r26, 0x07	; 7
 dc2:	9c 93       	st	X, r25
 dc4:	8e 93       	st	-X, r24
 dc6:	16 97       	sbiw	r26, 0x06	; 6
 dc8:	ce 01       	movw	r24, r28
 dca:	df 91       	pop	r29
 dcc:	cf 91       	pop	r28
 dce:	1f 91       	pop	r17
 dd0:	0f 91       	pop	r16
 dd2:	08 95       	ret

00000dd4 <__ultoa_invert>:
 dd4:	fa 01       	movw	r30, r20
 dd6:	aa 27       	eor	r26, r26
 dd8:	28 30       	cpi	r18, 0x08	; 8
 dda:	51 f1       	breq	.+84     	; 0xe30 <__ultoa_invert+0x5c>
 ddc:	20 31       	cpi	r18, 0x10	; 16
 dde:	81 f1       	breq	.+96     	; 0xe40 <__ultoa_invert+0x6c>
 de0:	e8 94       	clt
 de2:	6f 93       	push	r22
 de4:	6e 7f       	andi	r22, 0xFE	; 254
 de6:	6e 5f       	subi	r22, 0xFE	; 254
 de8:	7f 4f       	sbci	r23, 0xFF	; 255
 dea:	8f 4f       	sbci	r24, 0xFF	; 255
 dec:	9f 4f       	sbci	r25, 0xFF	; 255
 dee:	af 4f       	sbci	r26, 0xFF	; 255
 df0:	b1 e0       	ldi	r27, 0x01	; 1
 df2:	3e d0       	rcall	.+124    	; 0xe70 <__ultoa_invert+0x9c>
 df4:	b4 e0       	ldi	r27, 0x04	; 4
 df6:	3c d0       	rcall	.+120    	; 0xe70 <__ultoa_invert+0x9c>
 df8:	67 0f       	add	r22, r23
 dfa:	78 1f       	adc	r23, r24
 dfc:	89 1f       	adc	r24, r25
 dfe:	9a 1f       	adc	r25, r26
 e00:	a1 1d       	adc	r26, r1
 e02:	68 0f       	add	r22, r24
 e04:	79 1f       	adc	r23, r25
 e06:	8a 1f       	adc	r24, r26
 e08:	91 1d       	adc	r25, r1
 e0a:	a1 1d       	adc	r26, r1
 e0c:	6a 0f       	add	r22, r26
 e0e:	71 1d       	adc	r23, r1
 e10:	81 1d       	adc	r24, r1
 e12:	91 1d       	adc	r25, r1
 e14:	a1 1d       	adc	r26, r1
 e16:	20 d0       	rcall	.+64     	; 0xe58 <__ultoa_invert+0x84>
 e18:	09 f4       	brne	.+2      	; 0xe1c <__ultoa_invert+0x48>
 e1a:	68 94       	set
 e1c:	3f 91       	pop	r19
 e1e:	2a e0       	ldi	r18, 0x0A	; 10
 e20:	26 9f       	mul	r18, r22
 e22:	11 24       	eor	r1, r1
 e24:	30 19       	sub	r19, r0
 e26:	30 5d       	subi	r19, 0xD0	; 208
 e28:	31 93       	st	Z+, r19
 e2a:	de f6       	brtc	.-74     	; 0xde2 <__ultoa_invert+0xe>
 e2c:	cf 01       	movw	r24, r30
 e2e:	08 95       	ret
 e30:	46 2f       	mov	r20, r22
 e32:	47 70       	andi	r20, 0x07	; 7
 e34:	40 5d       	subi	r20, 0xD0	; 208
 e36:	41 93       	st	Z+, r20
 e38:	b3 e0       	ldi	r27, 0x03	; 3
 e3a:	0f d0       	rcall	.+30     	; 0xe5a <__ultoa_invert+0x86>
 e3c:	c9 f7       	brne	.-14     	; 0xe30 <__ultoa_invert+0x5c>
 e3e:	f6 cf       	rjmp	.-20     	; 0xe2c <__ultoa_invert+0x58>
 e40:	46 2f       	mov	r20, r22
 e42:	4f 70       	andi	r20, 0x0F	; 15
 e44:	40 5d       	subi	r20, 0xD0	; 208
 e46:	4a 33       	cpi	r20, 0x3A	; 58
 e48:	18 f0       	brcs	.+6      	; 0xe50 <__ultoa_invert+0x7c>
 e4a:	49 5d       	subi	r20, 0xD9	; 217
 e4c:	31 fd       	sbrc	r19, 1
 e4e:	40 52       	subi	r20, 0x20	; 32
 e50:	41 93       	st	Z+, r20
 e52:	02 d0       	rcall	.+4      	; 0xe58 <__ultoa_invert+0x84>
 e54:	a9 f7       	brne	.-22     	; 0xe40 <__ultoa_invert+0x6c>
 e56:	ea cf       	rjmp	.-44     	; 0xe2c <__ultoa_invert+0x58>
 e58:	b4 e0       	ldi	r27, 0x04	; 4
 e5a:	a6 95       	lsr	r26
 e5c:	97 95       	ror	r25
 e5e:	87 95       	ror	r24
 e60:	77 95       	ror	r23
 e62:	67 95       	ror	r22
 e64:	ba 95       	dec	r27
 e66:	c9 f7       	brne	.-14     	; 0xe5a <__ultoa_invert+0x86>
 e68:	00 97       	sbiw	r24, 0x00	; 0
 e6a:	61 05       	cpc	r22, r1
 e6c:	71 05       	cpc	r23, r1
 e6e:	08 95       	ret
 e70:	9b 01       	movw	r18, r22
 e72:	ac 01       	movw	r20, r24
 e74:	0a 2e       	mov	r0, r26
 e76:	06 94       	lsr	r0
 e78:	57 95       	ror	r21
 e7a:	47 95       	ror	r20
 e7c:	37 95       	ror	r19
 e7e:	27 95       	ror	r18
 e80:	ba 95       	dec	r27
 e82:	c9 f7       	brne	.-14     	; 0xe76 <__ultoa_invert+0xa2>
 e84:	62 0f       	add	r22, r18
 e86:	73 1f       	adc	r23, r19
 e88:	84 1f       	adc	r24, r20
 e8a:	95 1f       	adc	r25, r21
 e8c:	a0 1d       	adc	r26, r0
 e8e:	08 95       	ret

00000e90 <__prologue_saves__>:
 e90:	2f 92       	push	r2
 e92:	3f 92       	push	r3
 e94:	4f 92       	push	r4
 e96:	5f 92       	push	r5
 e98:	6f 92       	push	r6
 e9a:	7f 92       	push	r7
 e9c:	8f 92       	push	r8
 e9e:	9f 92       	push	r9
 ea0:	af 92       	push	r10
 ea2:	bf 92       	push	r11
 ea4:	cf 92       	push	r12
 ea6:	df 92       	push	r13
 ea8:	ef 92       	push	r14
 eaa:	ff 92       	push	r15
 eac:	0f 93       	push	r16
 eae:	1f 93       	push	r17
 eb0:	cf 93       	push	r28
 eb2:	df 93       	push	r29
 eb4:	cd b7       	in	r28, 0x3d	; 61
 eb6:	de b7       	in	r29, 0x3e	; 62
 eb8:	ca 1b       	sub	r28, r26
 eba:	db 0b       	sbc	r29, r27
 ebc:	0f b6       	in	r0, 0x3f	; 63
 ebe:	f8 94       	cli
 ec0:	de bf       	out	0x3e, r29	; 62
 ec2:	0f be       	out	0x3f, r0	; 63
 ec4:	cd bf       	out	0x3d, r28	; 61
 ec6:	09 94       	ijmp

00000ec8 <__epilogue_restores__>:
 ec8:	2a 88       	ldd	r2, Y+18	; 0x12
 eca:	39 88       	ldd	r3, Y+17	; 0x11
 ecc:	48 88       	ldd	r4, Y+16	; 0x10
 ece:	5f 84       	ldd	r5, Y+15	; 0x0f
 ed0:	6e 84       	ldd	r6, Y+14	; 0x0e
 ed2:	7d 84       	ldd	r7, Y+13	; 0x0d
 ed4:	8c 84       	ldd	r8, Y+12	; 0x0c
 ed6:	9b 84       	ldd	r9, Y+11	; 0x0b
 ed8:	aa 84       	ldd	r10, Y+10	; 0x0a
 eda:	b9 84       	ldd	r11, Y+9	; 0x09
 edc:	c8 84       	ldd	r12, Y+8	; 0x08
 ede:	df 80       	ldd	r13, Y+7	; 0x07
 ee0:	ee 80       	ldd	r14, Y+6	; 0x06
 ee2:	fd 80       	ldd	r15, Y+5	; 0x05
 ee4:	0c 81       	ldd	r16, Y+4	; 0x04
 ee6:	1b 81       	ldd	r17, Y+3	; 0x03
 ee8:	aa 81       	ldd	r26, Y+2	; 0x02
 eea:	b9 81       	ldd	r27, Y+1	; 0x01
 eec:	ce 0f       	add	r28, r30
 eee:	d1 1d       	adc	r29, r1
 ef0:	0f b6       	in	r0, 0x3f	; 63
 ef2:	f8 94       	cli
 ef4:	de bf       	out	0x3e, r29	; 62
 ef6:	0f be       	out	0x3f, r0	; 63
 ef8:	cd bf       	out	0x3d, r28	; 61
 efa:	ed 01       	movw	r28, r26
 efc:	08 95       	ret

00000efe <_exit>:
 efe:	f8 94       	cli

00000f00 <__stop_program>:
 f00:	ff cf       	rjmp	.-2      	; 0xf00 <__stop_program>
